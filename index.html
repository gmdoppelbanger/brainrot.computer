<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coco Labs - Brainrot Video Generator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg-primary: #3169C6;
      --bg-secondary: #245DC4;
      --bg-tertiary: #1C4FA8;
      --border-color: #0054E3;
      --text-primary: #000000;
      --text-secondary: #444444;
      --accent-primary: #0054E3;
      --accent-secondary: #316AC5;
      --accent-green: #008000;
      --accent-blue: #0054E3;
      --stewie-color: #CC6600;
      --peter-color: #008000;
      --danger: #CC0000;
      --window-bg: #ECE9D8;
      --window-border-light: #FFFFFF;
      --window-border-dark: #ACA899;
      --titlebar-start: #0A246A;
      --titlebar-end: #A6CAF0;
      --button-face: #ECE9D8;
      --button-highlight: #FFFFFF;
      --button-shadow: #ACA899;
      --button-dark-shadow: #716F64;
      --input-bg: #FFFFFF;
      --field-bg: #F0F0F0;
    }

    body {
      font-family: Tahoma, 'MS Sans Serif', Geneva, sans-serif;
      /* Orange desktop wallpaper */
      background: #EB632C;
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.4;
      font-size: 11px;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    /* Taskbar */
    .taskbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 28px;
      background: #C0C0C0;
      border-top: 2px solid #DFDFDF;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 2px 2px;
      z-index: 9999;
    }

    .start-button {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      background: #C0C0C0;
      border: 2px solid;
      border-color: #FFFFFF #808080 #808080 #FFFFFF;
      cursor: pointer;
      font-family: Tahoma, sans-serif;
      font-size: 11px;
      font-weight: bold;
      height: 22px;
    }

    .start-button:active {
      border-color: #808080 #FFFFFF #FFFFFF #808080;
    }

    .start-button img {
      width: 16px;
      height: 16px;
      image-rendering: pixelated;
    }

    .taskbar-tray {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 8px;
      height: 100%;
      background: #C0C0C0;
      border: 1px solid;
      border-color: #808080 #FFFFFF #FFFFFF #808080;
    }

    .taskbar-time {
      font-family: Tahoma, sans-serif;
      font-size: 11px;
      color: #000000;
    }

    .taskbar-middle {
      flex: 1;
      height: 100%;
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 0 4px;
      overflow: hidden;
    }

    .taskbar-window-btn {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      height: 22px;
      min-width: 120px;
      max-width: 160px;
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 45%, #D4D0C8 100%);
      border: 1px solid;
      border-color: #FFFFFF #808080 #808080 #FFFFFF;
      cursor: pointer;
      font-family: Tahoma, sans-serif;
      font-size: 11px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .taskbar-window-btn:hover {
      background: linear-gradient(180deg, #FFFFFF 0%, #F0EDE1 45%, #E3DED5 100%);
    }

    .taskbar-window-btn.active {
      border-color: #808080 #FFFFFF #FFFFFF #808080;
      background: linear-gradient(180deg, #D4D0C8 0%, #ECE9D8 100%);
    }

    .taskbar-window-btn img {
      width: 16px;
      height: 16px;
      image-rendering: pixelated;
      flex-shrink: 0;
    }

    .taskbar-window-btn span {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Start Menu */
    .start-menu {
      position: fixed;
      bottom: 30px;
      left: 2px;
      width: 200px;
      background: #C0C0C0;
      border: 2px solid;
      border-color: #FFFFFF #808080 #808080 #FFFFFF;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.4);
      display: none;
      z-index: 10000;
    }

    .start-menu.open {
      display: block;
    }

    .start-menu-sidebar {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 24px;
      background: linear-gradient(180deg, #000080 0%, #1084D0 100%);
      display: flex;
      align-items: flex-end;
      padding-bottom: 4px;
    }

    .start-menu-sidebar-text {
      color: #FFFFFF;
      font-size: 14px;
      font-weight: bold;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      transform: rotate(180deg);
      padding: 4px;
      letter-spacing: 1px;
    }

    .start-menu-items {
      margin-left: 24px;
      padding: 2px;
    }

    .start-menu-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      cursor: pointer;
      font-size: 11px;
      color: #000000;
    }

    .start-menu-item:hover {
      background: #000080;
      color: #FFFFFF;
    }

    .start-menu-item img {
      width: 16px;
      height: 16px;
      image-rendering: pixelated;
    }

    .start-menu-separator {
      height: 1px;
      background: #808080;
      margin: 2px 4px;
      border-bottom: 1px solid #FFFFFF;
    }

    /* Secondary floating windows */
    .floating-window {
      position: absolute;
      display: none;
      flex-direction: column;
      background: #C0C0C0;
      border: 2px solid;
      border-color: #DFDFDF #808080 #808080 #DFDFDF;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.4);
      min-width: 250px;
      min-height: 200px;
      z-index: 100;
    }

    .floating-window.active {
      z-index: 101;
    }

    /* Shaped window - no frame, just the image */
    .shaped-window {
      position: absolute;
      display: none;
      z-index: 100;
      cursor: move;
      user-select: none;
    }

    .shaped-window.active {
      z-index: 101;
    }

    .shaped-window img,
    .shaped-window .media-svg {
      display: block;
      width: 640px;
      pointer-events: none;
    }

    .media-svg {
      height: auto;
    }

    /* Layered PNG container */
    .layer-container {
      position: relative;
      width: 640px;
      height: auto;
    }

    .layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 640px;
      pointer-events: none;
    }

    /* Righthand is top layer */
    .layer-righthand {
      z-index: 4;
      transition: transform 0.3s ease-in-out;
    }

    .layer-righthand.hidden {
      transform: translate(319px, 47px);
    }

    /* Toggleback above frame, below righthand */
    .layer-toggleback {
      z-index: 3;
      transition: transform 0.3s ease-in-out;
    }

    .layer-toggleback.hidden {
      transform: translate(319px, 47px);
    }

    /* Frame is top layer - above righthand and media screen */
    .layer-frame {
      z-index: 7;
    }

    /* Main is bottom layer, relative to establish container height */
    .layer-main {
      position: relative;
      z-index: 1;
    }

    .shaped-window .close-hint {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }

    .shaped-window:hover .close-hint {
      opacity: 1;
    }

    /* Media player interactive controls */
    .media-controls {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .media-btn {
      position: absolute;
      background: transparent;
      border: none;
      outline: none !important;
      cursor: pointer;
      pointer-events: auto;
      color: transparent;
      font-size: 0;
      z-index: 11;
      transition: transform 0.3s ease-in-out;
      -webkit-tap-highlight-color: transparent;
    }

    .media-btn:focus,
    .media-btn:focus-visible,
    .media-btn:active {
      outline: none !important;
      border: none !important;
      box-shadow: none !important;
    }

    /* Custom instant tooltip */
    .media-btn::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s;
      z-index: 100;
    }

    .media-btn:hover::after {
      opacity: 1;
    }

    /* Buttons that move with right hand panel (preserving rotation) */
    .btn-play.hidden,
    .btn-pause.hidden,
    .btn-fastfwd.hidden {
      transform: translate(319px, 47px);
    }

    .btn-slide.hidden {
      transform: translate(319px, 47px) rotate(15deg);
    }

    .btn-next.hidden {
      transform: translate(319px, 47px) rotate(15deg);
    }

    /* Previous button - leftmost finger */
    .btn-prev {
      left: 52px;
      top: 572px;
      width: 28px;
      height: 28px;
    }

    /* Play button */
    .btn-play {
      left: 525px;
      top: 425px;
      width: 25px;
      height: 28px;
    }

    /* Stop button - middle finger */
    .btn-stop {
      left: 75px;
      top: 422px;
      width: 25px;
      height: 25px;
      transform: rotate(-10deg);
    }

    /* Next button - rightmost finger */
    .btn-next {
      left: 495px;
      top: 578px;
      width: 28px;
      height: 28px;
      transform: rotate(15deg);
    }

    /* Video screen overlay - above toggleback (3) and frame (2) layers */
    .media-screen {
      position: absolute;
      left: 168px;
      top: 372px;
      width: 295px;
      height: 195px;
      object-fit: cover;
      background: #000;
      border-radius: 20px;
      z-index: 5;
      pointer-events: auto;
      /*transform: rotate(-1.5deg);*/
    }

    /* Fast forward button */
    .btn-fastfwd {
      left: 500px;
      top: 525px;
      width: 28px;
      height: 28px;
    }

    /* Pause button */
    .btn-pause {
      left: 510px;
      top: 480px;
      width: 25px;
      height: 28px;
    }

    /* Rewind button */
    .btn-rewind {
      left: 60px;
      top: 525px;
      width: 28px;
      height: 28px;
    }

    /* Mute button */
    .btn-mute {
      left: 60px;
      top: 478px;
      width: 35px;
      height: 28px;
    }

    /* Slide toggle button */
    .btn-slide {
      left: 555px;
      top: 505px;
      width: 15px;
      height: 75px;
      transform: rotate(15deg);
    }

    /* Second slide toggle button - visible only when panel is slid out */
    .btn-slide-2 {
      left: 180px;
      top: 380px;
      width: 15px;
      transform: rotate(15deg);
      height: 125px;
      background: transparent !important;
      outline: none !important;
      z-index: 9999 !important;
      transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
      opacity: 0;
      pointer-events: none;
    }

    .btn-slide-2:focus,
    .btn-slide-2:active {
      outline: none !important;
      box-shadow: none !important;
    }

    .btn-slide-2::after {
      display: none !important;
    }

    .btn-slide-2.hidden {
      transform: translate(319px, 47px) rotate(10deg);
      opacity: 1;
      pointer-events: auto;
    }

    /* Sliding panel (bmp4.panel.png) - aligned with other layers by default */
    .slide-panel {
      position: absolute;
      left: 0;
      top: 0;
      width: 640px;
      height: auto;
      background: transparent;
      border: none;
      transform: translateY(0);
      transition: transform 0.3s ease-in-out;
      z-index: 0;
      pointer-events: auto;
    }

    .slide-panel.hidden {
      transform: translate(319px, 47px);
    }

    .slide-panel-img {
      width: 640px;
      height: auto;
      pointer-events: none;
    }

    .panel-filename-wrapper {
      position: absolute;
      left: 215px;
      top: 403px;
      max-width: 200px;
      overflow: hidden;
      transform: rotate(8.5deg);
    }

    .panel-filename {
      color: #fff;
      font-family: monospace;
      font-size: 12px;
      text-shadow: 1px 1px 2px #000;
      white-space: nowrap;
      display: inline-block;
    }

    .panel-filename.scrolling {
      animation: marquee 10s linear infinite;
    }

    @keyframes marquee {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }

    .panel-progress {
      position: absolute;
      left: 170px;
      top: 514px;
      width: 300px;
      height: 8px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      cursor: pointer;
      transform: rotate(8.5deg);
    }

    .panel-progress-fill {
      height: 100%;
      width: 0%;
      background: #6F803B;
      border-radius: 4px;
      transition: width 0.1s linear;
      max-width: 100%;
    }

    .panel-progress::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s;
      z-index: 100;
      margin-top: 5px;
    }

    .panel-progress:hover::after {
      opacity: 1;
    }

    .panel-playlist {
      position: absolute;
      left: 200px;
      top: 425px;
      width: 250px;
      max-height: 75px;
      overflow-y: auto;
      transform: rotate(9deg);
    }

    .panel-playlist::-webkit-scrollbar {
      width: 7px;
    }

    .panel-playlist::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0);
      /*border-radius: 2px;*/
    }

    .panel-playlist::-webkit-scrollbar-thumb {
      /*background: #6F803B;*/
      border-radius: 2px;
    }

    .panel-playlist-item {
      color: #aaa;
      font-family: monospace;
      font-size: 10px;
      padding: 2px 4px;
      cursor: pointer;
      text-shadow: 1px 1px 2px #000;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .panel-playlist-item:hover {
      color: #fff;
      background: rgba(255, 255, 255, 0.1);
    }

    .panel-playlist-item.active {
      color: #00ff00;
    }

    .close-btn {
      position: absolute;
      left: 445px;
      top: 100px;
      width: 18px;
      height: 18px;
      background: rgba(139, 69, 69, 0.8);
      border: 2px solid #8B0000;
      border-radius: 4px;
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      /*transform: rotate(9deg);*/
      display: flex;
      align-items: center;
      justify-content: center;
      text-shadow: 1px 1px 2px #000;
      /*box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);*/
      transition: background 0.2s, transform 0.2s;
      z-index: 9999;
    }

    .close-btn:hover {
      background: rgba(180, 50, 50, 0.9);
      transform: rotate(9deg) scale(1.1);
    }

    .close-btn:active {
      transform: rotate(9deg) scale(0.95);
    }

    .rotate-handle {
      position: absolute;
      left: 320px;
      top: 165px;
      width: 120px;
      height: 120px;
/*      background: rgba(70, 100, 139, 0.8);
      border: 2px solid #004080;*/
      border-radius: 50%;
/*      color: #fff;
      font-size: 12px;*/
      cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><text x="4" y="18" font-size="18" fill="%23333">â†º</text></svg>') 12 12, grab;
      display: flex;
      align-items: center;
      justify-content: center;
      text-shadow: 1px 1px 2px #000;
      transition: background 0.2s;
      z-index: 9999;
      user-select: none;
    }

    .rotate-handle:hover {
      background: rgba(254, 12, 84, 0.5);
    }

    .rotate-handle:active {
      cursor: grabbing;
    }

    .rotate-handle::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s;
      z-index: 10000;
      margin-bottom: 5px;
    }

    .rotate-handle:hover::after {
      opacity: 1;
    }

    /* Debug grid overlay */
    .debug-grid {
      display: none; /* Set to block to show debug grid */
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .debug-grid .grid-line-h {
      position: absolute;
      left: 0;
      width: 100%;
      height: 1px;
      background: rgba(255, 0, 0, 0.5);
    }

    .debug-grid .grid-line-v {
      position: absolute;
      top: 0;
      width: 1px;
      height: 100%;
      background: rgba(0, 0, 255, 0.5);
    }

    .debug-grid .grid-label {
      position: absolute;
      font-size: 10px;
      font-family: monospace;
      color: #fff;
      background: rgba(0,0,0,0.7);
      padding: 1px 3px;
      pointer-events: none;
    }

    .debug-grid .grid-label-h {
      left: 2px;
      transform: translateY(-50%);
    }

    .debug-grid .grid-label-v {
      top: 2px;
      transform: translateX(-50%);
    }

    .floating-window .window-titlebar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 3px;
      background: #000080;
      cursor: move;
      user-select: none;
    }

    .floating-window.inactive .window-titlebar {
      background: #808080;
    }

    .floating-window .window-title {
      display: flex;
      align-items: center;
      gap: 4px;
      color: #FFFFFF;
      font-size: 11px;
      font-weight: bold;
    }

    .floating-window .window-title img {
      width: 16px;
      height: 16px;
      image-rendering: pixelated;
    }

    .floating-window .window-controls {
      display: flex;
      gap: 2px;
    }

    .floating-window .win-btn {
      width: 16px;
      height: 14px;
      background: #C0C0C0;
      border: 1px solid;
      border-color: #FFFFFF #808080 #808080 #FFFFFF;
      font-size: 9px;
      color: #000000;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .floating-window .win-btn:active {
      border-color: #808080 #FFFFFF #FFFFFF #808080;
    }

    .floating-window .window-content {
      flex: 1;
      padding: 8px;
      background: #FFFFFF;
      margin: 3px;
      border: 1px solid;
      border-color: #808080 #FFFFFF #FFFFFF #808080;
      overflow: auto;
    }

    .floating-window .window-statusbar {
      padding: 2px 4px;
      background: #C0C0C0;
      border-top: 1px solid #808080;
      font-size: 11px;
      color: #000000;
    }

    .empty-folder-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #808080;
      font-size: 11px;
    }

    .folder-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      padding: 8px;
    }

    .folder-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 4px;
      width: 70px;
      cursor: pointer;
      border: 1px solid transparent;
    }

    .folder-item:hover {
      background: #316AC5;
      border: 1px dotted #FFFFFF;
    }

    .folder-item:hover span {
      color: #FFFFFF;
    }

    .folder-item img {
      width: 32px;
      height: 32px;
      image-rendering: pixelated;
    }

    .folder-item span {
      font-size: 11px;
      color: #000000;
      text-align: center;
      word-wrap: break-word;
    }

    /* Window Navigation Bar */
    .window-navbar {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 4px;
      background: #C0C0C0;
      border-bottom: 1px solid #808080;
    }

    .nav-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 22px;
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 45%, #D4D0C8 100%);
      border: 1px solid;
      border-color: #FFFFFF #808080 #808080 #FFFFFF;
      cursor: pointer;
      font-size: 10px;
      color: #000000;
    }

    .nav-btn:hover:not(:disabled) {
      background: linear-gradient(180deg, #FFFFFF 0%, #F0EDE1 45%, #E3DED5 100%);
    }

    .nav-btn:active:not(:disabled) {
      border-color: #808080 #FFFFFF #FFFFFF #808080;
    }

    .nav-btn:disabled {
      color: #808080;
      cursor: default;
    }

    .address-bar {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .address-bar-label {
      font-size: 11px;
      color: #000000;
    }

    .address-bar-input {
      flex: 1;
      height: 20px;
      padding: 2px 4px;
      background: #FFFFFF;
      border: 1px solid;
      border-color: #808080 #FFFFFF #FFFFFF #808080;
      font-size: 11px;
      font-family: Tahoma, sans-serif;
    }

    .address-bar-icon {
      width: 16px;
      height: 16px;
      image-rendering: pixelated;
    }

    /* Desktop icons */
    .desktop-icons {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      z-index: 0;
    }

    .desktop-icon {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      padding: 4px;
      border: 1px solid transparent;
      width: 70px;
    }

    .desktop-icon:hover {
      background: rgba(255, 255, 255, 0.2);
      border: 1px dotted #FFFFFF;
    }

    .desktop-icon.selected {
      background: rgba(0, 0, 128, 0.5);
      border: 1px dotted #FFFFFF;
    }

    .desktop-icon img {
      width: 32px;
      height: 32px;
      image-rendering: pixelated;
    }

    .desktop-icon-label {
      font-size: 11px;
      color: #FFFFFF;
      text-shadow: 1px 1px 1px #000000;
      text-align: center;
      word-wrap: break-word;
    }

    /* Classic scrollbar */
    ::-webkit-scrollbar {
      width: 16px;
      height: 16px;
    }
    ::-webkit-scrollbar-track {
      background: #F1EFE2;
      border: 1px solid #ACA899;
    }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(90deg, #ECE9D8 0%, #D4D0C8 50%, #ECE9D8 100%);
      border: 1px outset #FFFFFF;
      border-right-color: #716F64;
      border-bottom-color: #716F64;
    }
    ::-webkit-scrollbar-button {
      background: var(--button-face);
      border: 1px outset #FFFFFF;
      border-right-color: #716F64;
      border-bottom-color: #716F64;
    }

    .app {
      position: absolute;
      right: 30px;
      bottom: 55px;
      width: min(85vh, 85vw);
      height: min(85vh, 85vw);
      min-width: 350px;
      min-height: 300px;
      display: flex;
      flex-direction: column;
      padding: 3px;
      padding-top: 0;
      background: #C0C0C0;
      border: 2px solid;
      border-color: #DFDFDF #808080 #808080 #DFDFDF;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.4);
      overflow: hidden;
    }

    /* Resize handles */
    .resize-handle {
      position: absolute;
      background: transparent;
    }
    .resize-handle.right {
      top: 0;
      right: -4px;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
    }
    .resize-handle.bottom {
      bottom: -4px;
      left: 0;
      width: 100%;
      height: 8px;
      cursor: ns-resize;
    }
    .resize-handle.corner {
      right: 0;
      bottom: 0;
      width: 16px;
      height: 16px;
      cursor: nwse-resize;
      background: linear-gradient(
        135deg,
        transparent 0%,
        transparent 30%,
        #FFFFFF 30%,
        #FFFFFF 35%,
        #808080 35%,
        #808080 40%,
        transparent 40%,
        transparent 50%,
        #FFFFFF 50%,
        #FFFFFF 55%,
        #808080 55%,
        #808080 60%,
        transparent 60%,
        transparent 70%,
        #FFFFFF 70%,
        #FFFFFF 75%,
        #808080 75%,
        #808080 80%,
        transparent 80%
      );
      z-index: 10;
    }
    .resize-handle.left {
      top: 0;
      left: -4px;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
    }
    .resize-handle.top {
      top: -4px;
      left: 0;
      width: 100%;
      height: 8px;
      cursor: ns-resize;
    }
    .resize-handle.top-left {
      top: -4px;
      left: -4px;
      width: 16px;
      height: 16px;
      cursor: nwse-resize;
    }
    .resize-handle.top-right {
      top: -4px;
      right: -4px;
      width: 16px;
      height: 16px;
      cursor: nesw-resize;
    }
    .resize-handle.bottom-left {
      bottom: -4px;
      left: -4px;
      width: 16px;
      height: 16px;
      cursor: nesw-resize;
    }

    /* Header - Windows 98 Title Bar */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 3px;
      background: #000080;
      border: none;
      cursor: move;
      user-select: none;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .logo-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
    }

    .logo-icon svg {
      width: 100%;
      height: 100%;
    }

    .logo-text {
      font-size: 11px;
      font-weight: bold;
      color: #FFFFFF;
      text-shadow: none;
    }

    .logo-badge {
      display: none;
    }

    /* Windows 98 style window buttons */
    .window-controls {
      display: flex;
      gap: 2px;
    }

    .win-btn {
      width: 16px;
      height: 14px;
      background: #C0C0C0;
      border: 1px solid;
      border-color: #FFFFFF #808080 #808080 #FFFFFF;
      font-size: 9px;
      font-family: 'Marlett', sans-serif;
      color: #000000;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
    }
    .win-btn:active {
      border-color: #808080 #FFFFFF #FFFFFF #808080;
    }
    .win-btn span {
      font-family: Tahoma, sans-serif;
      font-size: 8px;
      font-weight: bold;
      line-height: 1;
    }

    /* Steps Navigation - Windows 98 Toolbar */
    .steps-nav {
      display: flex;
      justify-content: flex-start;
      gap: 2px;
      padding: 2px 4px;
      background: #C0C0C0;
      border-bottom: 1px solid #808080;
      flex-wrap: wrap;
    }

    .step-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 45%, #D4D0C8 100%);
      border: 1px solid;
      border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
      border-radius: 0;
      color: #000000;
      font-size: 11px;
      font-weight: normal;
      cursor: pointer;
      transition: none;
      position: relative;
      font-family: Tahoma, sans-serif;
    }

    .step-btn:disabled {
      color: #808080;
      cursor: not-allowed;
      text-shadow: 1px 1px 0 #FFFFFF;
    }
    .step-btn:not(:disabled):hover {
      background: linear-gradient(180deg, #FFFFFF 0%, #F0EDE1 45%, #E3DED5 100%);
    }
    .step-btn:not(:disabled):active {
      border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
      background: linear-gradient(180deg, #D4D0C8 0%, #ECE9D8 100%);
    }

    .step-btn.active {
      background: linear-gradient(180deg, #D4D0C8 0%, #ECE9D8 100%);
      border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
      color: #000000;
    }

    .step-btn.completed {
      color: var(--accent-green);
    }
    .step-icon { font-size: 14px; }

    .step-number {
      position: absolute;
      top: -6px;
      right: -6px;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #FF9900;
      border: 1px solid #996600;
      border-radius: 0;
      font-size: 9px;
      font-weight: bold;
      color: #000000;
    }

    .step-btn.active .step-number,
    .step-btn.completed .step-number {
      background: var(--accent-green);
      border-color: #006600;
      color: #FFFFFF;
    }

    /* Main Content - Window Body */
    .main-content {
      flex: 1;
      padding: 8px;
      background: #C0C0C0;
      border: none;
      max-width: none;
      margin: 0;
      width: 100%;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .step-panel { display: none; }
    .step-panel.active { display: block; }

    /* Section Styles - Windows XP Group Box */
    .section {
      background: var(--window-bg);
      border: 2px groove #D4D0C8;
      border-radius: 0;
      padding: 12px;
      max-width: 800px;
      margin: 0 auto;
      box-shadow: none;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #ACA899;
    }

    .section-title {
      font-size: 11px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 6px;
      color: #003399;
    }

    .section-subtitle {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    /* Buttons - Classic Windows XP */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 4px 16px;
      border-radius: 0;
      font-size: 11px;
      font-weight: normal;
      cursor: pointer;
      transition: none;
      border: 2px solid;
      font-family: Tahoma, sans-serif;
      min-height: 23px;
    }

    .btn-primary {
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 45%, #D4D0C8 100%);
      border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
      color: #000000;
    }

    .btn-primary:hover:not(:disabled) {
      background: linear-gradient(180deg, #FFFFFF 0%, #F0EDE1 45%, #E3DED5 100%);
      transform: none;
      box-shadow: none;
    }

    .btn-primary:active:not(:disabled) {
      border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
      background: linear-gradient(180deg, #D4D0C8 0%, #ECE9D8 100%);
    }

    .btn-primary:disabled {
      color: #808080;
      text-shadow: 1px 1px 0 #FFFFFF;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 45%, #D4D0C8 100%);
      border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
      color: #000000;
    }

    .btn-secondary:hover:not(:disabled) {
      background: linear-gradient(180deg, #FFFFFF 0%, #F0EDE1 45%, #E3DED5 100%);
    }
    .btn-secondary:active:not(:disabled) {
      border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
    }
    .btn-secondary:disabled {
      color: #808080;
      text-shadow: 1px 1px 0 #FFFFFF;
      cursor: not-allowed;
    }

    .btn-orange {
      background: linear-gradient(180deg, #FFBB55 0%, #FF9900 45%, #DD8800 100%);
      border-color: #FFDD99 #996600 #996600 #FFDD99;
      color: #000000;
      font-weight: bold;
    }

    .btn-orange:hover:not(:disabled) {
      background: linear-gradient(180deg, #FFCC77 0%, #FFAA22 45%, #EE9900 100%);
      transform: none;
      box-shadow: none;
    }

    .btn-orange:active:not(:disabled) {
      border-color: #996600 #FFDD99 #FFDD99 #996600;
      background: linear-gradient(180deg, #DD8800 0%, #FF9900 100%);
    }

    .btn-orange:disabled {
      color: #808080;
      background: linear-gradient(180deg, #E0E0E0 0%, #D0D0D0 100%);
      border-color: #FFFFFF #808080 #808080 #FFFFFF;
      cursor: not-allowed;
    }

    /* Secondary button on white backgrounds */
    .section .btn-secondary {
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 45%, #D4D0C8 100%);
      border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
      color: #000000;
    }

    .section .btn-secondary:hover:not(:disabled) {
      background: linear-gradient(180deg, #FFFFFF 0%, #F0EDE1 45%, #E3DED5 100%);
    }

    .nav-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #ACA899;
    }

    /* Script Editor */
    .dialogues-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 300px;
      overflow-y: auto;
      padding: 4px;
      background: #FFFFFF;
      border: 2px inset #ACA899;
    }

    .dialogue-row {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 8px;
      background: var(--field-bg);
      border: 1px solid #ACA899;
      border-radius: 0;
    }

    .dialogue-row.stewie { border-left: 3px solid var(--stewie-color); }
    .dialogue-row.peter { border-left: 3px solid var(--peter-color); }

    .dialogue-number {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #D4D0C8;
      border: 1px solid #808080;
      border-radius: 0;
      font-size: 10px;
      font-weight: bold;
      color: #000000;
      flex-shrink: 0;
    }

    .speaker-toggle {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      padding: 4px 8px;
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 45%, #D4D0C8 100%);
      border: 1px solid;
      border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
      border-radius: 0;
      cursor: pointer;
      min-width: 60px;
      flex-shrink: 0;
      font-family: Tahoma, sans-serif;
    }

    .speaker-toggle:hover {
      background: linear-gradient(180deg, #FFFFFF 0%, #F0EDE1 45%, #E3DED5 100%);
    }

    .speaker-toggle.stewie {
      border-color: var(--stewie-color);
      background: linear-gradient(180deg, #FFEEDD 0%, #FFCC99 100%);
    }
    .speaker-toggle.peter {
      border-color: var(--peter-color);
      background: linear-gradient(180deg, #DDFFDD 0%, #99FF99 100%);
    }

    .speaker-avatar { font-size: 16px; }

    .speaker-name {
      font-size: 9px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .speaker-toggle.stewie .speaker-name { color: #993300; }
    .speaker-toggle.peter .speaker-name { color: #006600; }

    .dialogue-input-container { flex: 1; position: relative; }

    .dialogue-input {
      width: 100%;
      padding: 4px 6px;
      background: #FFFFFF;
      border: 2px inset #ACA899;
      border-radius: 0;
      color: #000000;
      font-size: 11px;
      line-height: 1.4;
      resize: vertical;
      min-height: 50px;
      font-family: Tahoma, sans-serif;
    }

    .dialogue-input:focus {
      outline: none;
      border-color: var(--accent-blue);
      background: #FFFFCC;
    }

    /* Voice Sample Buttons */
    .sample-btn {
      padding: 2px 8px !important;
      min-width: 28px !important;
      font-size: 11px;
    }

    /* Dual Script Mode */
    .dual-inputs { display: flex; gap: 6px; flex: 1; }
    .dual-inputs .input-column { flex: 1; display: flex; flex-direction: column; gap: 2px; }
    .dual-inputs .input-label {
      font-size: 9px;
      font-weight: bold;
      text-transform: uppercase;
      color: #003399;
    }
    .dual-inputs .input-label.audio { color: #993300; }
    .dual-inputs .input-label.caption { color: #006600; }
    .dual-inputs .dialogue-input { min-height: 40px; font-size: 11px; }

    .toggle-container {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      background: var(--field-bg);
      border: 1px solid #808080;
      border-radius: 0;
      font-size: 11px;
      cursor: pointer;
      color: #000000;
    }
    .toggle-container:hover { background: #E0E0E0; }
    .toggle-switch {
      width: 28px;
      height: 14px;
      background: #D4D0C8;
      border: 2px inset #ACA899;
      border-radius: 0;
      position: relative;
      transition: background 0.1s;
    }
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 10px;
      height: 10px;
      background: linear-gradient(180deg, #FFFFFF 0%, #D4D0C8 100%);
      border: 1px outset #FFFFFF;
      border-radius: 0;
      top: 0;
      left: 0;
      transition: left 0.1s;
    }
    .toggle-container.active .toggle-switch { background: var(--accent-green); }
    .toggle-container.active .toggle-switch::after { left: 14px; }

    .remove-btn {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 100%);
      border: 1px solid;
      border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
      border-radius: 0;
      color: #000000;
      font-size: 11px;
      cursor: pointer;
    }

    .remove-btn:hover {
      background: linear-gradient(180deg, #FFCCCC 0%, #FF9999 100%);
      border-color: #CC0000;
    }

    .add-dialogue-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      width: 100%;
      padding: 6px;
      margin-top: 8px;
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 100%);
      border: 2px dashed #808080;
      border-radius: 0;
      color: #000000;
      font-size: 11px;
      font-weight: normal;
      cursor: pointer;
      font-family: Tahoma, sans-serif;
    }

    .add-dialogue-btn:hover {
      border-color: var(--accent-blue);
      background: linear-gradient(180deg, #E8F4FC 0%, #D4E8F8 100%);
    }

    /* Voice Generator */
    .voice-selection {
      margin-bottom: 12px;
      padding: 12px;
      background: var(--field-bg);
      border: 2px groove #D4D0C8;
      border-radius: 0;
    }

    .voice-selection h3 {
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 8px;
      color: #003399;
    }

    .voice-selectors {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .voice-selector { display: flex; flex-direction: column; gap: 4px; }

    .voice-selector label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      font-weight: bold;
    }

    .voice-selector.stewie label { color: #993300; }
    .voice-selector.peter label { color: #006600; }

    .voice-selector select {
      padding: 4px 6px;
      background: #FFFFFF;
      border: 2px inset #ACA899;
      border-radius: 0;
      color: #000000;
      font-size: 11px;
      cursor: pointer;
      font-family: Tahoma, sans-serif;
    }

    .generate-section { margin-bottom: 12px; }

    .generate-btn {
      width: 100%;
      padding: 8px 16px;
      font-size: 11px;
      min-height: 28px;
    }

    .api-key-section {
      margin-bottom: 12px;
      padding: 10px;
      background: linear-gradient(180deg, #FFFFCC 0%, #FFFFAA 100%);
      border: 2px solid #999900;
      border-radius: 0;
    }

    .api-key-section label {
      display: block;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 4px;
      color: #666600;
    }

    .api-key-input {
      display: flex;
      gap: 4px;
    }

    .api-key-input input {
      flex: 1;
      padding: 4px 6px;
      background: #FFFFFF;
      border: 2px inset #ACA899;
      border-radius: 0;
      color: #000000;
      font-size: 11px;
      font-family: 'Courier New', monospace;
    }

    .progress-container { margin-top: 8px; }

    .progress-bar {
      height: 16px;
      background: #FFFFFF;
      border: 2px inset #ACA899;
      border-radius: 0;
      overflow: hidden;
      padding: 2px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg,
        #00AA00 0%, #00CC00 25%, #00AA00 50%, #00CC00 75%, #00AA00 100%);
      background-size: 20px 100%;
      animation: progress-stripe 0.5s linear infinite;
      border-radius: 0;
      transition: width 0.2s;
      width: 0%;
    }

    @keyframes progress-stripe {
      0% { background-position: 0 0; }
      100% { background-position: 20px 0; }
    }

    .progress-text {
      margin-top: 4px;
      font-size: 11px;
      color: #000000;
      text-align: center;
    }

    .audio-list {
      background: #FFFFFF;
      border: 2px inset #ACA899;
      border-radius: 0;
      overflow: hidden;
      margin-top: 12px;
    }

    .audio-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 10px;
      background: linear-gradient(180deg, #F5F4EA 0%, #ECE9D8 100%);
      border-bottom: 1px solid #ACA899;
    }

    .audio-list-header h3 { font-size: 11px; font-weight: bold; color: #003399; }
    .total-duration { font-size: 11px; color: #006600; font-weight: bold; }

    .audio-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-bottom: 1px solid #D4D0C8;
      background: #FFFFFF;
    }

    .audio-item:last-child { border-bottom: none; }
    .audio-item:nth-child(even) { background: #F5F5F5; }
    .audio-item.stewie { border-left: 3px solid var(--stewie-color); }
    .audio-item.peter { border-left: 3px solid var(--peter-color); }

    .audio-index {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #D4D0C8;
      border: 1px solid #808080;
      border-radius: 0;
      font-size: 9px;
      font-weight: bold;
      color: #000000;
    }

    .audio-speaker { font-size: 14px; }

    .audio-text {
      flex: 1;
      font-size: 11px;
      color: #000000;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .audio-text-input {
      flex: 1;
      font-size: 11px;
      color: #000000;
      background: #FFFFFF;
      border: 2px inset #ACA899;
      border-radius: 0;
      padding: 2px 4px;
      font-family: Tahoma, sans-serif;
    }
    .audio-text-input:focus {
      outline: none;
      background: #FFFFCC;
    }

    .audio-duration { font-size: 10px; color: #666666; font-family: 'Courier New', monospace; }

    .play-btn {
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #00CC00 0%, #009900 100%);
      border: 1px solid;
      border-color: #00FF00 #006600 #006600 #00FF00;
      border-radius: 0;
      color: #FFFFFF;
      font-size: 10px;
      cursor: pointer;
      font-weight: bold;
    }

    .play-btn:hover {
      background: linear-gradient(180deg, #00EE00 0%, #00AA00 100%);
    }
    .play-btn:active {
      border-color: #006600 #00FF00 #00FF00 #006600;
    }

    /* Aspect Ratio */
    .ratio-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 12px;
    }

    .ratio-card {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px;
      background: linear-gradient(180deg, #FFFFFF 0%, #F0F0F0 100%);
      border: 2px solid;
      border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
      border-radius: 0;
      cursor: pointer;
      font-family: Tahoma, sans-serif;
      color: #000000;
    }

    .ratio-card:hover {
      background: linear-gradient(180deg, #FFFFFF 0%, #E8F4FC 100%);
    }
    .ratio-card.selected {
      border-color: var(--accent-blue);
      background: linear-gradient(180deg, #E8F4FC 0%, #CCE8FF 100%);
      border-width: 3px;
    }

    .ratio-preview-container {
      width: 100%;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }

    .ratio-preview {
      background: #D4D0C8;
      border: 2px inset #ACA899;
      border-radius: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ratio-icon { font-size: 18px; font-weight: bold; color: #666666; }
    .ratio-info { text-align: center; }
    .ratio-label { font-size: 14px; font-weight: bold; margin-bottom: 2px; color: #003399; }
    .ratio-description { font-size: 10px; color: #666666; margin-bottom: 2px; }
    .ratio-dimensions { font-size: 9px; font-family: 'Courier New', monospace; color: #808080; }

    .selected-badge {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-green);
      border: 1px solid #006600;
      border-radius: 0;
      color: #FFFFFF;
      font-size: 12px;
      font-weight: bold;
    }

    /* Preview & Export */
    .export-step {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 12px;
      max-width: 900px;
      margin: 0 auto;
    }

    .video-preview {
      background: var(--window-bg);
      border: 2px groove #D4D0C8;
      border-radius: 0;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      width: 100%;
      padding-bottom: 6px;
      border-bottom: 1px solid #ACA899;
    }

    .preview-header h3 { font-size: 11px; font-weight: bold; color: #003399; }

    .preview-ratio {
      padding: 2px 6px;
      background: #D4D0C8;
      border: 1px solid #808080;
      border-radius: 0;
      font-size: 10px;
      font-family: 'Courier New', monospace;
      color: #000000;
    }

    .preview-container {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 350px;
      height: 350px;
      background: #000000;
      border: 2px inset #ACA899;
      border-radius: 0;
      overflow: hidden;
    }

    #previewCanvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 0;
      box-shadow: none;
    }

    .preview-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
      padding: 8px;
      background: linear-gradient(180deg, #F5F4EA 0%, #ECE9D8 100%);
      border: 2px groove #D4D0C8;
      border-radius: 0;
      width: 100%;
      box-sizing: border-box;
    }

    .control-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #FFFFFF 0%, #ECE9D8 100%);
      border: 2px solid;
      border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
      border-radius: 0;
      color: #000000;
      font-size: 12px;
      cursor: pointer;
    }

    .control-btn:hover { background: linear-gradient(180deg, #FFFFFF 0%, #F0EDE1 100%); }
    .control-btn:active {
      border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
    }

    .control-btn.play-control {
      width: 36px;
      height: 36px;
      background: linear-gradient(180deg, #00CC00 0%, #009900 100%);
      border-color: #00FF00 #006600 #006600 #00FF00;
      color: #FFFFFF;
      font-size: 14px;
      font-weight: bold;
    }

    .time-display {
      font-size: 11px;
      font-family: 'Courier New', monospace;
      color: #000000;
      min-width: 70px;
      text-align: center;
      background: #000000;
      color: #00FF00;
      padding: 2px 6px;
      border: 2px inset #ACA899;
    }

    .preview-progress {
      height: 16px;
      background: #FFFFFF;
      border: 2px inset #ACA899;
      border-radius: 0;
      margin-top: 8px;
      cursor: pointer;
      overflow: hidden;
      width: 100%;
      padding: 2px;
    }

    .preview-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #0066CC 0%, #0099FF 50%, #0066CC 100%);
      border-radius: 0;
      width: 0%;
    }

    .export-panel {
      background: var(--window-bg);
      border: 2px groove #D4D0C8;
      border-radius: 0;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .export-panel h3 { font-size: 11px; font-weight: bold; color: #003399; border-bottom: 1px solid #ACA899; padding-bottom: 4px; }

    .export-info {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 10px;
      background: #FFFFFF;
      border: 2px inset #ACA899;
      border-radius: 0;
    }

    .info-item { display: flex; justify-content: space-between; align-items: center; }
    .info-label { font-size: 11px; color: #666666; }
    .info-value { font-size: 11px; font-weight: bold; font-family: 'Courier New', monospace; color: #000000; }

    .export-btn { width: 100%; padding: 8px 16px; font-size: 11px; min-height: 28px; }

    .spinner {
      width: 14px;
      height: 14px;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      display: inline-block;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .error-banner {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 0;
      margin-bottom: 12px;
      background: linear-gradient(180deg, #FFCCCC 0%, #FF9999 100%);
      border: 2px solid #CC0000;
      color: #660000;
      font-size: 11px;
    }

    @media (max-width: 900px) {
      .export-step { grid-template-columns: 1fr; }
      .ratio-grid { grid-template-columns: 1fr; }
      .voice-selectors { grid-template-columns: 1fr; }
    }

    /* Windows XP Focus Ring */
    button:focus, input:focus, select:focus, textarea:focus {
      outline: 1px dotted #000000;
      outline-offset: -3px;
    }

    /* Links */
    a {
      color: #0066CC;
      text-decoration: underline;
    }
    a:hover {
      color: #3399FF;
    }
    a:visited {
      color: #800080;
    }

    /* ===== VIDEO POPUP MODAL - Classic Windows Media Player Style ===== */
    .video-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      justify-content: center;
      align-items: center;
    }
    .video-modal-overlay.active {
      display: flex;
    }

    .video-popup-window {
      background: #ECE9D8;
      border: 3px solid;
      border-color: #FFFFFF #404040 #404040 #FFFFFF;
      box-shadow: 4px 4px 10px rgba(0,0,0,0.5), inset 1px 1px 0 #DFDFDF;
      max-width: 420px;
      width: 90%;
      animation: popup-open 0.2s ease-out;
    }

    @keyframes popup-open {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    .video-popup-titlebar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 3px;
      background: #000080;
      cursor: default;
      user-select: none;
    }

    .video-popup-title {
      display: flex;
      align-items: center;
      gap: 4px;
      color: #FFFFFF;
      font-size: 11px;
      font-weight: bold;
      text-shadow: none;
    }

    .video-popup-title-icon {
      width: 16px;
      height: 16px;
      background: #C0C0C0;
      border: 1px solid #808080;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #000080;
    }

    .video-popup-close {
      width: 16px;
      height: 14px;
      background: #C0C0C0;
      border: 1px solid;
      border-color: #FFFFFF #808080 #808080 #FFFFFF;
      color: #000000;
      font-size: 9px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Tahoma, sans-serif;
    }
    .video-popup-close:hover {
      background: #D4D0C8;
    }
    .video-popup-close:active {
      border-color: #808080 #FFFFFF #FFFFFF #808080;
    }

    .video-popup-menubar {
      display: flex;
      gap: 0;
      padding: 2px 4px;
      background: #C0C0C0;
      border-bottom: 1px solid #808080;
      font-size: 11px;
    }
    .video-popup-menu-item {
      padding: 2px 8px;
      cursor: default;
    }
    .video-popup-menu-item:hover {
      background: #316AC5;
      color: #FFFFFF;
    }

    .video-popup-content {
      padding: 0;
      background: #000000;
    }

    .video-popup-screen {
      width: 100%;
      aspect-ratio: 1/1;
      background: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .video-popup-canvas {
      max-width: 100%;
      max-height: 100%;
    }

    .video-popup-controls {
      background: linear-gradient(180deg, #3C3C3C 0%, #1E1E1E 50%, #2A2A2A 100%);
      padding: 6px 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .video-popup-progress-container {
      width: 100%;
      height: 10px;
      background: #000000;
      border: 1px inset #333333;
      position: relative;
      cursor: pointer;
    }
    .video-popup-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #6699CC 0%, #99CCFF 50%, #6699CC 100%);
      width: 0%;
    }

    .video-popup-buttons {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }

    .video-popup-btn {
      width: 28px;
      height: 22px;
      background: linear-gradient(180deg, #5A5A5A 0%, #3A3A3A 50%, #4A4A4A 100%);
      border: 1px solid;
      border-color: #6A6A6A #2A2A2A #2A2A2A #6A6A6A;
      color: #CCCCCC;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .video-popup-btn:hover {
      background: linear-gradient(180deg, #6A6A6A 0%, #4A4A4A 50%, #5A5A5A 100%);
      color: #FFFFFF;
    }
    .video-popup-btn:active {
      border-color: #2A2A2A #6A6A6A #6A6A6A #2A2A2A;
    }
    .video-popup-btn.play-btn-large {
      width: 36px;
      height: 26px;
      font-size: 12px;
    }

    .video-popup-time {
      color: #00FF00;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      background: #000000;
      padding: 2px 6px;
      border: 1px inset #333333;
      margin-left: auto;
    }

    .video-popup-volume {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: 8px;
    }
    .video-popup-volume-icon {
      color: #AAAAAA;
      font-size: 10px;
    }
    .video-popup-volume-slider {
      width: 50px;
      height: 6px;
      background: #000000;
      border: 1px inset #333333;
      position: relative;
    }
    .video-popup-volume-fill {
      height: 100%;
      background: linear-gradient(90deg, #00AA00 0%, #00FF00 100%);
      width: 70%;
    }

    .video-popup-statusbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 4px;
      background: #ECE9D8;
      border-top: 1px solid #ACA899;
      font-size: 10px;
      color: #666666;
    }
    .video-popup-status-text {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .video-popup-status-text::before {
      content: '';
      width: 8px;
      height: 8px;
      background: #00AA00;
      border-radius: 50%;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    /* Hide the regular preview section when popup is active */
    .video-preview.hidden-for-popup {
      visibility: hidden;
    }

    /* Preview placeholder button to open popup */
    .open-preview-btn {
      width: 100%;
      padding: 40px 20px;
      background: linear-gradient(180deg, #2A2A2A 0%, #1A1A1A 100%);
      border: 2px inset #ACA899;
      color: #AAAAAA;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      font-family: Tahoma, sans-serif;
    }
    .open-preview-btn:hover {
      background: linear-gradient(180deg, #3A3A3A 0%, #2A2A2A 100%);
      color: #FFFFFF;
    }
    .open-preview-btn-icon {
      font-size: 32px;
    }
  </style>
  <!-- FFmpeg.wasm for high-quality video export (local files) -->
  <script src="ffmpeg/ffmpeg.min.js"></script>
</head>
<body>
  <!-- Desktop Icons -->
  <div class="desktop-icons">
    <div class="desktop-icon" ondblclick="document.getElementById('appWindow').style.display='flex'">
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABBUlEQVR4nO2W3RHCIAzHU88ZnCcdQifAPTJIJtANfErXcQl80GqPEj5aoA/2/9I7ApdfSUgC8O/qYhsQ0ZZyJiIzn8eUg0RUBAARZ2tJAO/Dz1XORU7e9WQAAABjzqqN+Z5HtASAeZGPcgAAy/4yCmCM9WY6cxd9JWt10AzM19q+AWASghrxzQKoEd9MgItjMk0A1Bxopc0BJiG4OaZHWwC3Vrt9Q6vlxQBC8nWxZgAi4q2GRBScE4goqYp+AXLbbalbyWxGvwkpNqSM+7QbHPUxGuU6eXZYRLJGNESs3tDqyFbUdNAN5sAwDCAigIjFvq42L8Vqglhrbd/31RzHXseuXc30AmqGtsnDGGTAAAAAAElFTkSuQmCC" alt="My Computer">
      <span class="desktop-icon-label">My Computer</span>
    </div>
    <div class="desktop-icon" ondblclick="openWindow('myDocumentsWindow')">
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAi0lEQVR4nO2WUQqAIBBEx/BGdqeu4TXyTHWm7ctFg8BM1j7mfQgR2zw0ZABCJuNuz9I5N0RAjr1taN3GSfgcDgAhvJpt3a0nnC4ARCR+/F47Z4q6i75+YyeRWcwT/yZQH0GINqnFUfMfoAAFKECB6QLVVZySTWhZfLSQtNaxUeRCogK28cqwcktINxfLtBbLbL6+OAAAAABJRU5ErkJggg==" alt="My Documents">
      <span class="desktop-icon-label">My Documents</span>
    </div>
    <div class="desktop-icon" ondblclick="openWindow('recycleBinWindow')">
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA6ElEQVR4nO2WXQ6EIAyE62YPNjdzjlZP1n3RVYjy063JGv1eBIx0oENR5OHuDJ6PABiAZExVRVW753t7BMwikv44jjIMrvXsY4EAsKM4xR2YpiluRQe8To9QobgDJE8X0O0aM7Oj1JDsPgldKSCZmElVk/f5yQgXIFI3ZsnxIQKiua4AQHfbpwkws29ul4Dk2l7H2OUD112givmpifPzU9HCdT0QRVMK8uqXmm5tL5WbpJC0lqro2oHFA+TWD/BM5U/BNqA3+E8CoqgKKN1+JVrrwf/vwJa80NT6LVSPSe/1muP5VX+4Fx/sZrElKSIHFQAAAABJRU5ErkJggg==" alt="Recycle Bin">
      <span class="desktop-icon-label">Recycle Bin</span>
    </div>
    <div class="desktop-icon" ondblclick="openWindow('mediaPlayerWindow')">
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABZElEQVR4nOWXvW3DMBBGPwYZQQE8gAHTQHo1HkGFMoNHiMdQNkhmiAuPoEZ1ApgGMoABawemukDin8gTbQTJVTYs33t3FE8U8N9DXCmvjuXd3wjsjbvMAsmRUyC5eoC5BIdNYcGqtuekShMgcLla2D9eUyAIBvDw9smCRwkcNoU2wcV6CQAQuz0bHCVgwovXj+7ny8tTOZuOwCAawkdgM4EQXpHL9tFcnpmDaFj183sXggO0VOH7wykwqn69dLZ7Cu7LW7X9qAvsQaSbmvvXUVgCVvUZo1wtrCHG7oDY7SGlhJRylhRrFBOcgj4rpaxraan645cz1596Gt5OQDe11W6lFGtnsE9EuqlHzwKCp0o4R3HurUg3YHc6I9sgyhVOgartRXc6A/Bvn9gIVe8V8CXhwkPhFRh2gSMxvN5XPRDxYhI6EU2Bp+BRAiQB+M+ErqDuheDRAikisWCWgCniiljwr4lvfwOXiqxH2kwAAAAASUVORK5CYII=" alt="Brainrot Media Player">
      <span class="desktop-icon-label">Brainrot Media Player</span>
    </div>
  </div>

  <!-- Brainrot Media Player Window (layered PNGs) -->
  <div class="shaped-window" id="mediaPlayerWindow" onmousedown="startDragWindow(event, 'mediaPlayerWindow')">
    <!-- Layered PNGs (main at bottom, frame on top - panel is now sliding) -->
    <div class="layer-container">
      <img src="/assets/bmp4.main-D4yhRuTv.png" class="layer layer-main" id="layerMain" draggable="false">
      <img src="/assets/bmp4.toggleback-C7pL9DqL.png" class="layer layer-toggleback" id="layerToggleback" draggable="false">
      <img src="/assets/bmp4.right%20hand-Bz6z3dIZ.png" class="layer layer-righthand" id="layerRightHand" draggable="false">
      <img src="/assets/bmp4.frame-CTPqztBr.png" class="layer layer-frame" id="layerFrame" draggable="false">
    </div>

    <!-- Video player screen -->
    <video class="media-screen" id="mediaVideo" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()">
      <source src="brainrot-videos/gameplay1.mp4" type="video/mp4">
    </video>

    <!-- Debug grid overlay -->
    <div class="debug-grid" id="debugGrid"></div>

    <!-- Interactive button overlays -->
    <div class="media-controls">
      <button class="media-btn btn-mute" id="btnMute" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" data-tooltip="Mute">ðŸ”Š</button>
      <button class="media-btn btn-rewind" id="btnRewind" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" data-tooltip="Rewind">âª</button>
      <button class="media-btn btn-prev" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" data-tooltip="Previous">â—€â—€</button>
      <button class="media-btn btn-play" id="btnPlay" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" data-tooltip="Play">â–¶</button>
      <button class="media-btn btn-pause" id="btnPause" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" data-tooltip="Pause">â¸</button>
      <button class="media-btn btn-stop" id="btnStop" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" data-tooltip="Stop">â– </button>
      <button class="media-btn btn-next" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" data-tooltip="Next">â–¶â–¶</button>
      <button class="media-btn btn-fastfwd" id="btnFastFwd" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" data-tooltip="Fast Forward">â©</button>
      <button class="media-btn btn-slide" id="btnSlide" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" onclick="toggleSlidePanel()" data-tooltip="Toggle brainrot panel">â˜°</button>
      <button class="media-btn btn-slide-2" id="btnSlide2" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" onclick="toggleSlidePanel()"></button>
    </div>

    <!-- Sliding panel (uses bmp4.panel.png) -->
    <div class="slide-panel" id="slidePanel">
      <img src="/assets/bmp4.panel-CkC6OTHV.png" class="slide-panel-img" draggable="false">
      <div class="panel-filename-wrapper">
        <span class="panel-filename" id="panelFilename">Now Playing: gameplay1.mp4</span>
      </div>
      <div class="panel-progress" id="panelProgress" onmousedown="event.stopPropagation()" data-tooltip="Rotting in progress..">
        <div class="panel-progress-fill" id="panelProgressFill"></div>
      </div>
      <div class="panel-playlist" id="panelPlaylist" onmousedown="event.stopPropagation()"></div>
    </div>

    <!-- Close button (separate from panel, topmost layer) -->
    <button class="close-btn" onclick="closeWindow('mediaPlayerWindow')" onmousedown="event.stopPropagation()" ondblclick="event.stopPropagation()" title="Close">âœ•</button>

    <!-- Rotate handle -->
    <div class="rotate-handle" id="rotateHandle" onmousedown="event.stopPropagation()" data-tooltip="Drag to rotate"> </div>
  </div>

  <!-- My Documents Window -->
  <div class="floating-window" id="myDocumentsWindow" style="width: 400px; height: 320px;">
    <div class="window-titlebar" onmousedown="startDragWindow(event, 'myDocumentsWindow')">
      <div class="window-title">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAi0lEQVR4nO2WUQqAIBBEx/BGdqeu4TXyTHWm7ctFg8BM1j7mfQgR2zw0ZABCJuNuz9I5N0RAjr1taN3GSfgcDgAhvJpt3a0nnC4ARCR+/F47Z4q6i75+YyeRWcwT/yZQH0GINqnFUfMfoAAFKECB6QLVVZySTWhZfLSQtNaxUeRCogK28cqwcktINxfLtBbLbL6+OAAAAABJRU5ErkJggg==" alt="">
        <span>My Documents</span>
      </div>
      <div class="window-controls">
        <button class="win-btn" onclick="minimizeWindow('myDocumentsWindow')" title="Minimize"><span>_</span></button>
        <button class="win-btn" title="Maximize"><span>&#9633;</span></button>
        <button class="win-btn" onclick="closeWindow('myDocumentsWindow')" title="Close"><span>&#10005;</span></button>
      </div>
    </div>
    <div class="window-navbar">
      <button class="nav-btn" disabled title="Back">&#9664;</button>
      <button class="nav-btn" disabled title="Forward">&#9654;</button>
      <button class="nav-btn" title="Up">&#9650;</button>
      <div class="address-bar">
        <span class="address-bar-label">Address</span>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAi0lEQVR4nO2WUQqAIBBEx/BGdqeu4TXyTHWm7ctFg8BM1j7mfQgR2zw0ZABCJuNuz9I5N0RAjr1taN3GSfgcDgAhvJpt3a0nnC4ARCR+/F47Z4q6i75+YyeRWcwT/yZQH0GINqnFUfMfoAAFKECB6QLVVZySTWhZfLSQtNaxUeRCogK28cqwcktINxfLtBbLbL6+OAAAAABJRU5ErkJggg==" class="address-bar-icon" alt="">
        <input type="text" class="address-bar-input" value="C:\My Documents" readonly>
      </div>
    </div>
    <div class="window-content">
      <div class="folder-grid">
        <div class="folder-item">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAi0lEQVR4nO2WUQqAIBBEx/BGdqeu4TXyTHWm7ctFg8BM1j7mfQgR2zw0ZABCJuNuz9I5N0RAjr1taN3GSfgcDgAhvJpt3a0nnC4ARCR+/F47Z4q6i75+YyeRWcwT/yZQH0GINqnFUfMfoAAFKECB6QLVVZySTWhZfLSQtNaxUeRCogK28cqwcktINxfLtBbLbL6+OAAAAABJRU5ErkJggg==" alt="Folder">
          <span>My Influences</span>
        </div>
        <div class="folder-item">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAi0lEQVR4nO2WUQqAIBBEx/BGdqeu4TXyTHWm7ctFg8BM1j7mfQgR2zw0ZABCJuNuz9I5N0RAjr1taN3GSfgcDgAhvJpt3a0nnC4ARCR+/F47Z4q6i75+YyeRWcwT/yZQH0GINqnFUfMfoAAFKECB6QLVVZySTWhZfLSQtNaxUeRCogK28cqwcktINxfLtBbLbL6+OAAAAABJRU5ErkJggg==" alt="Folder">
          <span>My Pictures</span>
        </div>
        <div class="folder-item">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAi0lEQVR4nO2WUQqAIBBEx/BGdqeu4TXyTHWm7ctFg8BM1j7mfQgR2zw0ZABCJuNuz9I5N0RAjr1taN3GSfgcDgAhvJpt3a0nnC4ARCR+/F47Z4q6i75+YyeRWcwT/yZQH0GINqnFUfMfoAAFKECB6QLVVZySTWhZfLSQtNaxUeRCogK28cqwcktINxfLtBbLbL6+OAAAAABJRU5ErkJggg==" alt="Folder">
          <span>My Videos</span>
        </div>
      </div>
    </div>
    <div class="window-statusbar">3 object(s)</div>
  </div>

  <!-- Recycle Bin Window -->
  <div class="floating-window" id="recycleBinWindow" style="width: 350px; height: 280px;">
    <div class="window-titlebar" onmousedown="startDragWindow(event, 'recycleBinWindow')">
      <div class="window-title">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA6ElEQVR4nO2WXQ6EIAyE62YPNjdzjlZP1n3RVYjy063JGv1eBIx0oENR5OHuDJ6PABiAZExVRVW753t7BMwikv44jjIMrvXsY4EAsKM4xR2YpiluRQe8To9QobgDJE8X0O0aM7Oj1JDsPgldKSCZmElVk/f5yQgXIFI3ZsnxIQKiua4AQHfbpwkws29ul4Dk2l7H2OUD112givmpifPzU9HCdT0QRVMK8uqXmm5tL5WbpJC0lqro2oHFA+TWD/BM5U/BNqA3+E8CoqgKKN1+JVrrwf/vwJa80NT6LVSPSe/1muP5VX+4Fx/sZrElKSIHFQAAAABJRU5ErkJggg==" alt="">
        <span>Recycle Bin</span>
      </div>
      <div class="window-controls">
        <button class="win-btn" onclick="minimizeWindow('recycleBinWindow')" title="Minimize"><span>_</span></button>
        <button class="win-btn" title="Maximize"><span>&#9633;</span></button>
        <button class="win-btn" onclick="closeWindow('recycleBinWindow')" title="Close"><span>&#10005;</span></button>
      </div>
    </div>
    <div class="window-content">
      <div class="empty-folder-message">
        <span>Recycle Bin is empty</span>
      </div>
    </div>
    <div class="window-statusbar">0 object(s)</div>
  </div>

  <!-- Start Menu -->
  <div class="start-menu" id="startMenu">
    <div class="start-menu-sidebar">
      <span class="start-menu-sidebar-text">Brainrot</span>
    </div>
    <div class="start-menu-items">
      <div class="start-menu-item" onclick="openWindow('myDocumentsWindow'); toggleStartMenu();">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAi0lEQVR4nO2WUQqAIBBEx/BGdqeu4TXyTHWm7ctFg8BM1j7mfQgR2zw0ZABCJuNuz9I5N0RAjr1taN3GSfgcDgAhvJpt3a0nnC4ARCR+/F47Z4q6i75+YyeRWcwT/yZQH0GINqnFUfMfoAAFKECB6QLVVZySTWhZfLSQtNaxUeRCogK28cqwcktINxfLtBbLbL6+OAAAAABJRU5ErkJggg==" alt="">
        <span>My Documents</span>
      </div>
      <div class="start-menu-item" onclick="document.getElementById('appWindow').style.display='flex'; toggleStartMenu();">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABBUlEQVR4nO2W3RHCIAzHU88ZnCcdQifAPTJIJtANfErXcQl80GqPEj5aoA/2/9I7ApdfSUgC8O/qYhsQ0ZZyJiIzn8eUg0RUBAARZ2tJAO/Dz1XORU7e9WQAAABjzqqN+Z5HtASAeZGPcgAAy/4yCmCM9WY6cxd9JWt10AzM19q+AWASghrxzQKoEd9MgItjMk0A1Bxopc0BJiG4OaZHWwC3Vrt9Q6vlxQBC8nWxZgAi4q2GRBScE4goqYp+AXLbbalbyWxGvwkpNqSM+7QbHPUxGuU6eXZYRLJGNESs3tDqyFbUdNAN5sAwDCAigIjFvq42L8Vqglhrbd/31RzHXseuXc30AmqGtsnDGGTAAAAAAElFTkSuQmCC" alt="">
        <span>Brainrot Generator</span>
      </div>
      <div class="start-menu-separator"></div>
      <div class="start-menu-item" onclick="openWindow('recycleBinWindow'); toggleStartMenu();">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA6ElEQVR4nO2WXQ6EIAyE62YPNjdzjlZP1n3RVYjy063JGv1eBIx0oENR5OHuDJ6PABiAZExVRVW753t7BMwikv44jjIMrvXsY4EAsKM4xR2YpiluRQe8To9QobgDJE8X0O0aM7Oj1JDsPgldKSCZmElVk/f5yQgXIFI3ZsnxIQKiua4AQHfbpwkws29ul4Dk2l7H2OUD112givmpifPzU9HCdT0QRVMK8uqXmm5tL5WbpJC0lqro2oHFA+TWD/BM5U/BNqA3+E8CoqgKKN1+JVrrwf/vwJa80NT6LVSPSe/1muP5VX+4Fx/sZrElKSIHFQAAAABJRU5ErkJggg==" alt="">
        <span>Recycle Bin</span>
      </div>
      <div class="start-menu-separator"></div>
      <div class="start-menu-item" onclick="alert('Shutting down...'); toggleStartMenu();">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABBUlEQVR4nO2W3RHCIAzHU88ZnCcdQifAPTJIJtANfErXcQl80GqPEj5aoA/2/9I7ApdfSUgC8O/qYhsQ0ZZyJiIzn8eUg0RUBAARZ2tJAO/Dz1XORU7e9WQAAABjzqqN+Z5HtASAeZGPcgAAy/4yCmCM9WY6cxd9JWt10AzM19q+AWASghrxzQKoEd9MgItjMk0A1Bxopc0BJiG4OaZHWwC3Vrt9Q6vlxQBC8nWxZgAi4q2GRBScE4goqYp+AXLbbalbyWxGvwkpNqSM+7QbHPUxGuU6eXZYRLJGNESs3tDqyFbUdNAN5sAwDCAigIjFvq42L8Vqglhrbd/31RzHXseuXc30AmqGtsnDGGTAAAAAAElFTkSuQmCC" alt="">
        <span>Shut Down...</span>
      </div>
    </div>
  </div>

  <!-- Taskbar -->
  <div class="taskbar">
    <button class="start-button" onclick="toggleStartMenu()">
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABBUlEQVR4nO2W3RHCIAzHU88ZnCcdQifAPTJIJtANfErXcQl80GqPEj5aoA/2/9I7ApdfSUgC8O/qYhsQ0ZZyJiIzn8eUg0RUBAARZ2tJAO/Dz1XORU7e9WQAAABjzqqN+Z5HtASAeZGPcgAAy/4yCmCM9WY6cxd9JWt10AzM19q+AWASghrxzQKoEd9MgItjMk0A1Bxopc0BJiG4OaZHWwC3Vrt9Q6vlxQBC8nWxZgAi4q2GRBScE4goqYp+AXLbbalbyWxGvwkpNqSM+7QbHPUxGuU6eXZYRLJGNESs3tDqyFbUdNAN5sAwDCAigIjFvq42L8Vqglhrbd/31RzHXseuXc30AmqGtsnDGGTAAAAAAElFTkSuQmCC" alt="">
      <span>Start</span>
    </button>
    <div class="taskbar-middle"></div>
    <div class="taskbar-tray">
      <span class="taskbar-time" id="taskbarTime">12:00 PM</span>
    </div>
  </div>

  <div class="app" id="appWindow">
    <!-- Resize handles -->
    <div class="resize-handle top"></div>
    <div class="resize-handle right"></div>
    <div class="resize-handle bottom"></div>
    <div class="resize-handle left"></div>
    <div class="resize-handle corner"></div>
    <div class="resize-handle top-left"></div>
    <div class="resize-handle top-right"></div>
    <div class="resize-handle bottom-left"></div>

    <header class="header" id="windowHeader">
      <div class="logo" onclick="window.location.reload()" style="cursor: pointer;" title="Back to start">
        <span class="logo-icon">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABBUlEQVR4nO2W3RHCIAzHU88ZnCcdQifAPTJIJtANfErXcQl80GqPEj5aoA/2/9I7ApdfSUgC8O/qYhsQ0ZZyJiIzn8eUg0RUBAARZ2tJAO/Dz1XORU7e9WQAAABjzqqN+Z5HtASAeZGPcgAAy/4yCmCM9WY6cxd9JWt10AzM19q+AWASghrxzQKoEd9MgItjMk0A1Bxopc0BJiG4OaZHWwC3Vrt9Q6vlxQBC8nWxZgAi4q2GRBScE4goqYp+AXLbbalbyWxGvwkpNqSM+7QbHPUxGuU6eXZYRLJGNESs3tDqyFbUdNAN5sAwDCAigIjFvq42L8Vqglhrbd/31RzHXseuXc30AmqGtsnDGGTAAAAAAElFTkSuQmCC" alt="" style="width: 16px; height: 16px; image-rendering: pixelated;">
        </span>
        <span class="logo-text">Brainrot Video Generator</span>
      </div>
      <div class="window-controls">
        <button class="win-btn" onclick="minimizeWindow('appWindow')" title="Minimize"><span>_</span></button>
        <button class="win-btn" onclick="alert('Maximize functionality not available')" title="Maximize"><span>&#9633;</span></button>
        <button class="win-btn" onclick="closeWindow('appWindow')" title="Close"><span>&#10005;</span></button>
      </div>
    </header>

    <div class="steps-nav">
      <button class="step-btn active" data-step="1">
        <span class="step-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z"/></svg></span>
        <span class="step-title">Write Script</span>
        <span class="step-number">1</span>
      </button>
      <button class="step-btn" data-step="2" disabled>
        <span class="step-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/><path d="M19 10v2a7 7 0 01-14 0v-2M12 19v4M8 23h8"/></svg></span>
        <span class="step-title">Generate Voice</span>
        <span class="step-number">2</span>
      </button>
      <button class="step-btn" data-step="3" disabled>
        <span class="step-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M9 21V9"/></svg></span>
        <span class="step-title">Select Format</span>
        <span class="step-number">3</span>
      </button>
      <button class="step-btn" data-step="4" disabled>
        <span class="step-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg></span>
        <span class="step-title">Preview & Export</span>
        <span class="step-number">4</span>
      </button>
    </div>

    <main class="main-content">
      <!-- Landing: Paste Full Script -->
      <div class="step-panel active" data-panel="0" id="landingPanel">
        <div class="section" style="max-width: 700px; margin: 0 auto;">
          <div class="section-header" style="text-align: center; display: block;">
            <h2 class="section-title" style="justify-content: center;">Paste Your Script</h2>
            <p class="section-subtitle">Paste your full script below. Each line becomes a dialogue. Lines alternate between Stewie and Peter.</p>
          </div>

          <textarea id="fullScriptInput" placeholder="Line 1 - Stewie says this
Line 2 - Peter says this
Line 3 - Stewie says this
..." style="width: 100%; min-height: 200px; padding: 6px; border-radius: 0; border: 2px inset #ACA899; background: #FFFFFF; color: #000000; font-size: 11px; line-height: 1.4; resize: vertical; font-family: Tahoma, sans-serif;"></textarea>

          <div style="display: flex; gap: 8px; margin-top: 12px; justify-content: center;">
            <button class="btn btn-orange" onclick="parseFullScript()" style="padding: 4px 20px;">
              &#10004; Done - Generate Dialogues
            </button>
            <button class="btn btn-secondary" onclick="skipToManualEntry()" style="padding: 4px 16px;">
              &#8594; Skip - Enter Manually
            </button>
          </div>

        </div>
      </div>

      <!-- Step 1: Script Editor -->
      <div class="step-panel" data-panel="1">
        <div class="section">
          <div class="section-header">
            <div>
              <h2 class="section-title">Write Your Script</h2>
              <p class="section-subtitle">Add dialogue lines for Stewie and Peter. Click the avatar to switch speakers.</p>
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
              <div class="toggle-container" id="dualScriptToggle" onclick="toggleDualScriptMode()">
                <div class="toggle-switch"></div>
                <span>Advanced Mode</span>
              </div>
              <div id="dialogueCount" style="padding: 6px 12px; background: #f5f5f5; border: 1px solid rgba(0,0,0,0.1); border-radius: 8px; font-size: 13px; color: #666666;">2 lines</div>
            </div>
          </div>

          <div class="dialogues-container" id="dialoguesContainer"></div>

          <button class="add-dialogue-btn" id="addDialogueBtn">
            <span>+</span> Add Dialogue
          </button>

          <div class="nav-buttons">
            <button class="btn btn-secondary" onclick="backToLanding()"><span>â†</span> Back to Paste</button>
            <button class="btn btn-orange" id="toStep2Btn" disabled>Generate Voice <span>â†’</span></button>
          </div>
        </div>
      </div>

      <!-- Step 2: Voice Generator -->
      <div class="step-panel" data-panel="2">
        <div class="section">
          <div class="section-header">
            <div>
              <h2 class="section-title">Generate Voice</h2>
              <p class="section-subtitle">Select voices and generate AI speech for each dialogue line</p>
            </div>
          </div>

          <div id="errorBanner" class="error-banner" style="display: none;"></div>

          <div class="api-key-section">
            <label>ElevenLabs API Key</label>
            <p style="font-size: 12px; color: #666666; margin-bottom: 8px;">
              Get your key from <a href="https://elevenlabs.io/app/settings/api-keys" target="_blank" style="color: var(--accent-blue);">elevenlabs.io/app/settings/api-keys</a>
            </p>
            <div class="api-key-input">
              <input type="password" id="apiKeyInput" placeholder="sk_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" style="font-size: 13px;">
              <button class="btn btn-secondary" id="toggleKeyVisibility" onclick="toggleApiKeyVisibility()" style="padding: 8px 12px; min-width: auto;">Show</button>
              <button class="btn btn-secondary" id="loadVoicesBtn">Load Voices</button>
            </div>
            <p id="keyDebug" style="font-size: 11px; color: #666666; margin-top: 6px;"></p>
          </div>

          <div class="voice-selection" id="voiceSelection" style="display: none;">
            <h3>Select Voices</h3>
            <div class="voice-selectors">
              <div class="voice-selector stewie">
                <label>Stewie's Voice</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                  <select id="stewieVoice" style="flex: 1;"></select>
                  <button class="btn btn-secondary sample-btn" id="playStewieSample" onclick="playVoiceSample('stewie')" title="Preview voice">â–¶</button>
                </div>
              </div>
              <div class="voice-selector peter">
                <label>Peter's Voice</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                  <select id="peterVoice" style="flex: 1;"></select>
                  <button class="btn btn-secondary sample-btn" id="playPeterSample" onclick="playVoiceSample('peter')" title="Preview voice">â–¶</button>
                </div>
              </div>
            </div>
            <p id="sampleStatus" style="font-size: 11px; color: #666666; margin-top: 8px;"></p>
          </div>

          <div class="generate-section">
            <button class="btn btn-orange generate-btn" id="generateBtn" disabled>
              Generate Audio Script
            </button>
            <div class="progress-container" id="progressContainer" style="display: none;">
              <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
              <div class="progress-text" id="progressText"></div>
            </div>
          </div>

          <div class="audio-list" id="audioList" style="display: none;">
            <div class="audio-list-header">
              <h3>Generated Audio</h3>
              <div style="display: flex; gap: 12px; align-items: center;">
                <span class="total-duration" id="totalDuration">Total: 0s</span>
                <button class="btn btn-secondary" onclick="downloadAllAudio()" style="padding: 4px 10px; font-size: 12px;">â†“ Download All</button>
              </div>
            </div>
            <div id="audioItems"></div>
          </div>

          <div class="nav-buttons">
            <button class="btn btn-secondary" id="backToStep1"><span>â†</span> Back</button>
            <button class="btn btn-orange" id="toStep3Btn" disabled>Select Format <span>â†’</span></button>
          </div>
        </div>
      </div>

      <!-- Step 3: Aspect Ratio -->
      <div class="step-panel" data-panel="3">
        <div class="section">
          <div class="section-header">
            <div>
              <h2 class="section-title">Select Aspect Ratio</h2>
              <p class="section-subtitle">Choose the video format for your target platform</p>
            </div>
          </div>

          <div class="ratio-grid">
            <button class="ratio-card" data-ratio="9:16">
              <div class="ratio-preview-container">
                <div class="ratio-preview" style="width: 67px; height: 120px;"><span class="ratio-icon">9:16</span></div>
              </div>
              <div class="ratio-info">
                <div class="ratio-label">9:16</div>
                <div class="ratio-description">Shorts, Reels, TikToks</div>
                <div class="ratio-dimensions">1080 Ã— 1920</div>
              </div>
            </button>
            <button class="ratio-card" data-ratio="16:9">
              <div class="ratio-preview-container">
                <div class="ratio-preview" style="width: 120px; height: 67px;"><span class="ratio-icon">16:9</span></div>
              </div>
              <div class="ratio-info">
                <div class="ratio-label">16:9</div>
                <div class="ratio-description">YouTube</div>
                <div class="ratio-dimensions">1920 Ã— 1080</div>
              </div>
            </button>
            <button class="ratio-card selected" data-ratio="1:1">
              <div class="ratio-preview-container">
                <div class="ratio-preview" style="width: 100px; height: 100px;"><span class="ratio-icon">1:1</span></div>
              </div>
              <div class="ratio-info">
                <div class="ratio-label">1:1</div>
                <div class="ratio-description">X, Instagram, LinkedIn</div>
                <div class="ratio-dimensions">1080 Ã— 1080</div>
              </div>
              <div class="selected-badge">âœ“</div>
            </button>
          </div>

          <div class="nav-buttons">
            <button class="btn btn-secondary" id="backToStep2"><span>â†</span> Back</button>
            <button class="btn btn-orange" id="toStep4Btn">Preview & Export <span>â†’</span></button>
          </div>
        </div>
      </div>

      <!-- Step 4: Preview & Export -->
      <div class="step-panel" data-panel="4">
        <div class="export-step">
          <div class="video-preview">
            <div class="preview-header">
              <h3>Preview</h3>
              <span class="preview-ratio" id="previewRatio">16:9</span>
            </div>
            <!-- Hidden canvas and video for rendering -->
            <video id="bgVideo" muted playsinline crossorigin="anonymous" style="display: none;"></video>
            <canvas id="previewCanvas" style="display: none;"></canvas>

            <!-- Button to open video popup -->
            <button class="open-preview-btn" id="openPreviewBtn" onclick="openVideoPopup()">
              <span class="open-preview-btn-icon">&#9658;</span>
              <span>Click to Open Video Preview</span>
              <span style="font-size: 10px; color: #666666;">Video Player</span>
            </button>
          </div>

          <div class="export-panel">
            <h3>Export Video</h3>
            <div class="export-info">
              <div class="info-item">
                <span class="info-label">Duration</span>
                <span class="info-value" id="exportDuration">0s</span>
              </div>
              <div class="info-item">
                <span class="info-label">Resolution</span>
                <span class="info-value" id="exportResolution">1920Ã—1080</span>
              </div>
              <div class="info-item">
                <span class="info-label">Dialogues</span>
                <span class="info-value" id="exportDialogues">0</span>
              </div>
            </div>

            <button class="btn btn-orange export-btn" id="exportBtn">
              Generate Video
            </button>

            <div class="progress-container" id="exportProgress" style="display: none;">
              <div class="progress-bar"><div class="progress-fill" id="exportProgressFill"></div></div>
              <div class="progress-text" id="exportProgressText"></div>
            </div>

            <div class="nav-buttons" style="margin-top: auto; padding-top: 16px; border-top: 1px solid var(--border-color);">
              <button class="btn btn-orange" id="backToStep3"><span>â†</span> Back</button>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- VIDEO POPUP MODAL - Classic Windows Media Player -->
  <div class="video-modal-overlay" id="videoModalOverlay">
    <div class="video-popup-window">
      <div class="video-popup-titlebar">
        <div class="video-popup-title">
          <div class="video-popup-title-icon">&#9658;</div>
          <span>Brainrot Preview</span>
        </div>
        <button class="video-popup-close" id="videoPopupClose" onclick="closeVideoPopup()">X</button>
      </div>
      <div class="video-popup-menubar">
        <span class="video-popup-menu-item"><u>F</u>ile</span>
        <span class="video-popup-menu-item"><u>V</u>iew</span>
        <span class="video-popup-menu-item"><u>P</u>lay</span>
        <span class="video-popup-menu-item"><u>T</u>ools</span>
        <span class="video-popup-menu-item"><u>H</u>elp</span>
      </div>
      <div class="video-popup-content">
        <div class="video-popup-screen">
          <canvas id="popupPreviewCanvas" class="video-popup-canvas"></canvas>
        </div>
        <div class="video-popup-controls">
          <div class="video-popup-progress-container" id="popupProgress" onclick="seekPopupVideo(event)">
            <div class="video-popup-progress-fill" id="popupProgressFill"></div>
          </div>
          <div class="video-popup-buttons">
            <button class="video-popup-btn" onclick="popupStop()" title="Stop">&#9632;</button>
            <button class="video-popup-btn" onclick="popupRewind()" title="Rewind">&#9668;&#9668;</button>
            <button class="video-popup-btn play-btn-large" id="popupPlayPauseBtn" onclick="togglePopupPlayback()" title="Play/Pause">&#9658;</button>
            <button class="video-popup-btn" onclick="popupForward()" title="Forward">&#9658;&#9658;</button>
            <div class="video-popup-time" id="popupTimeDisplay">00:00 / 00:00</div>
            <div class="video-popup-volume">
              <span class="video-popup-volume-icon">&#128266;</span>
              <div class="video-popup-volume-slider">
                <div class="video-popup-volume-fill"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="video-popup-statusbar">
        <span class="video-popup-status-text">Playing...</span>
        <span id="popupRatioDisplay">1:1</span>
      </div>
    </div>
  </div>

  <script>
    // ========== STATE ==========
    const state = {
      currentStep: 1,
      dialogues: [
        { id: 1, speaker: 'stewie', text: '', audioText: '', captionText: '' },
        { id: 2, speaker: 'peter', text: '', audioText: '', captionText: '' }
      ],
      audioData: [],
      aspectRatio: '1:1',
      voices: null,
      selectedVoices: { stewie: '', peter: '' },
      isGenerating: false,
      isPlaying: false,
      currentTime: 0,
      dualScriptMode: false  // Toggle for separate audio/caption scripts
    };

    const ASPECT_RATIOS = {
      '9:16': { width: 1080, height: 1920 },
      '16:9': { width: 1920, height: 1080 },
      '1:1': { width: 1080, height: 1080 }
    };

    // ========== CHARACTER IMAGES & BACKGROUND VIDEO ==========
    const characterImages = {
      stewie: null,
      peter: null
    };

    let backgroundVideo = null;
    let bgVideoStartTime = 0;

    // Multiple gameplay videos for variety
    const GAMEPLAY_VIDEOS = [
      'gameplay1.mp4'
    ];

    function getRandomGameplayVideo() {
      return GAMEPLAY_VIDEOS[Math.floor(Math.random() * GAMEPLAY_VIDEOS.length)];
    }

    async function loadCharacterImages() {
      const loadImage = (srcs) => new Promise((resolve) => {
        const tryLoad = (index) => {
          if (index >= srcs.length) {
            resolve(null);
            return;
          }
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => tryLoad(index + 1);
          img.src = srcs[index];
        };
        tryLoad(0);
      });

      characterImages.stewie = await loadImage([
        'src/assets/Stewie.png',
        'src/assets/stewie.png',
        'src/assets/STEWIE.png'
      ]);
      characterImages.peter = await loadImage([
        'src/assets/Peter.png',
        'src/assets/peter.png',
        'src/assets/PETER.png'
      ]);

      // Use the video element in the DOM for preview
      backgroundVideo = document.getElementById('bgVideo');
      backgroundVideo.src = getRandomGameplayVideo();
      backgroundVideo.muted = true;
      backgroundVideo.loop = true;
      backgroundVideo.playsInline = true;
      console.log('Initial gameplay video:', backgroundVideo.src);

      await new Promise((resolve) => {
        backgroundVideo.onloadedmetadata = () => {
          const maxStart = Math.max(0, backgroundVideo.duration - 120);
          bgVideoStartTime = Math.random() * maxStart;
          backgroundVideo.currentTime = bgVideoStartTime;
          console.log('Background video loaded:', backgroundVideo.duration + 's, starting at ' + bgVideoStartTime.toFixed(1) + 's');
          resolve();
        };
        backgroundVideo.onerror = () => {
          console.log('Background video not found, using gradient fallback');
          backgroundVideo = null;
          resolve();
        };
      });

      console.log('Character images loaded:', {
        stewie: characterImages.stewie ? `${characterImages.stewie.width}x${characterImages.stewie.height}` : 'not found',
        peter: characterImages.peter ? `${characterImages.peter.width}x${characterImages.peter.height}` : 'not found'
      });
    }

    // ========== UTILITY FUNCTIONS ==========
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function getTotalDuration() {
      return state.audioData.reduce((sum, a) => sum + (a.duration || 2), 0);
    }

    function getDialogueTimings() {
      let time = 0;
      return state.audioData.map(audio => {
        const timing = {
          ...audio,
          start: time,
          end: time + (audio.duration || 2)
        };
        time += audio.duration || 2;
        return timing;
      });
    }

    // ========== DOM REFERENCES ==========
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => document.querySelectorAll(sel);

    // ========== STEP NAVIGATION ==========
    function goToStep(step) {
      state.currentStep = step;

      // Update step buttons
      $$('.step-btn').forEach((btn, i) => {
        const btnStep = i + 1;
        btn.classList.remove('active', 'completed');
        if (btnStep === step) btn.classList.add('active');
        else if (btnStep < step) btn.classList.add('completed');
        btn.disabled = btnStep > step;
      });

      // Update panels
      $$('.step-panel').forEach(panel => {
        panel.classList.remove('active');
        if (parseInt(panel.dataset.panel) === step) {
          panel.classList.add('active');
        }
      });

      // Step-specific setup
      if (step === 4) {
        setupPreview();
      }
    }

    // ========== SCRIPT EDITOR ==========
    function toggleDualScriptMode() {
      state.dualScriptMode = !state.dualScriptMode;
      const toggle = $('#dualScriptToggle');
      toggle.classList.toggle('active', state.dualScriptMode);

      // When enabling dual mode, copy text to both fields if empty
      if (state.dualScriptMode) {
        state.dialogues.forEach(d => {
          if (!d.audioText && d.text) d.audioText = d.text;
          if (!d.captionText && d.text) d.captionText = d.text;
        });
      }

      renderDialogues();
    }

    function renderDialogues() {
      const container = $('#dialoguesContainer');
      const isDual = state.dualScriptMode;

      container.innerHTML = state.dialogues.map((d, i) => `
        <div class="dialogue-row ${d.speaker}" data-id="${d.id}">
          <div class="dialogue-number">${i + 1}</div>
          <button class="speaker-toggle ${d.speaker}" onclick="toggleSpeaker(${d.id})">
            <div class="speaker-avatar">${d.speaker === 'stewie' ? 'S' : 'P'}</div>
            <span class="speaker-name">${d.speaker === 'stewie' ? 'Stewie' : 'Peter'}</span>
          </button>
          ${isDual ? `
            <div class="dual-inputs">
              <div class="input-column">
                <span class="input-label audio">Audio (pronunciation)</span>
                <textarea class="dialogue-input" placeholder="Script for TTS (adjust spelling for pronunciation)"
                  oninput="updateDialogue(${d.id}, 'audioText', this.value)">${d.audioText || ''}</textarea>
              </div>
              <div class="input-column">
                <span class="input-label caption">Caption (display)</span>
                <textarea class="dialogue-input" placeholder="Script for captions (correct spelling)"
                  oninput="updateDialogue(${d.id}, 'captionText', this.value)">${d.captionText || ''}</textarea>
              </div>
            </div>
          ` : `
            <div class="dialogue-input-container">
              <textarea class="dialogue-input" placeholder="What does ${d.speaker === 'stewie' ? 'Stewie' : 'Peter'} say?"
                oninput="updateDialogue(${d.id}, 'text', this.value)">${d.text}</textarea>
            </div>
          `}
          <button class="remove-btn" onclick="removeDialogue(${d.id})" ${state.dialogues.length <= 2 ? 'disabled' : ''}>âœ•</button>
        </div>
      `).join('');

      $('#dialogueCount').textContent = `${state.dialogues.length} lines`;

      // Check if any dialogue has content
      const hasContent = state.dialogues.some(d => {
        if (isDual) {
          return (d.audioText?.trim() || d.captionText?.trim());
        }
        return d.text?.trim();
      });
      $('#toStep2Btn').disabled = !hasContent;
    }

    function toggleSpeaker(id) {
      const d = state.dialogues.find(d => d.id === id);
      if (d) {
        d.speaker = d.speaker === 'stewie' ? 'peter' : 'stewie';
        renderDialogues();
      }
    }

    function updateDialogue(id, field, value) {
      const d = state.dialogues.find(d => d.id === id);
      if (d) {
        d[field] = value;

        // In single mode, also update audioText/captionText for potential later use
        if (field === 'text') {
          d.audioText = value;
          d.captionText = value;
        }

        // Check if any dialogue has content
        const hasContent = state.dialogues.some(d => {
          if (state.dualScriptMode) {
            return (d.audioText?.trim() || d.captionText?.trim());
          }
          return d.text?.trim();
        });
        $('#toStep2Btn').disabled = !hasContent;
      }
    }

    function removeDialogue(id) {
      if (state.dialogues.length > 2) {
        state.dialogues = state.dialogues.filter(d => d.id !== id);
        renderDialogues();
      }
    }

    function addDialogue() {
      const lastSpeaker = state.dialogues[state.dialogues.length - 1]?.speaker || 'peter';
      state.dialogues.push({
        id: Date.now(),
        speaker: lastSpeaker === 'stewie' ? 'peter' : 'stewie',
        text: '',
        audioText: '',
        captionText: ''
      });
      renderDialogues();
    }

    // Landing page functions
    function parseFullScript() {
      const input = $('#fullScriptInput').value.trim();
      if (!input) {
        skipToManualEntry();
        return;
      }

      // Split by line breaks and filter empty lines
      const lines = input.split(/\r?\n/).filter(line => line.trim());

      if (lines.length === 0) {
        skipToManualEntry();
        return;
      }

      // Create dialogues from lines, alternating speakers starting with Stewie
      state.dialogues = lines.map((line, index) => ({
        id: Date.now() + index,
        speaker: index % 2 === 0 ? 'stewie' : 'peter',
        text: line.trim(),
        audioText: '',
        captionText: ''
      }));

      // Go to script editor
      showScriptEditor();
    }

    function skipToManualEntry() {
      // Reset to default 2 dialogues
      state.dialogues = [
        { id: 1, speaker: 'stewie', text: '', audioText: '', captionText: '' },
        { id: 2, speaker: 'peter', text: '', audioText: '', captionText: '' }
      ];
      showScriptEditor();
    }

    function showScriptEditor() {
      $('#landingPanel').classList.remove('active');
      $('[data-panel="1"]').classList.add('active');
      renderDialogues();
    }

    function backToLanding() {
      $('[data-panel="1"]').classList.remove('active');
      $('#landingPanel').classList.add('active');
    }

    // Helper: Get text for TTS (uses audioText in dual mode, text otherwise)
    function getAudioText(dialogue) {
      if (state.dualScriptMode && dialogue.audioText?.trim()) {
        return dialogue.audioText;
      }
      return dialogue.text || dialogue.audioText || '';
    }

    // Helper: Get text for captions (uses captionText in dual mode, text otherwise)
    function getCaptionText(dialogue) {
      if (state.dualScriptMode && dialogue.captionText?.trim()) {
        return dialogue.captionText;
      }
      return dialogue.text || dialogue.captionText || '';
    }

    // ========== ELEVENLABS INTEGRATION ==========
    function toggleApiKeyVisibility() {
      const input = $('#apiKeyInput');
      const btn = $('#toggleKeyVisibility');
      if (input.type === 'password') {
        input.type = 'text';
        btn.textContent = 'ðŸ”’';
      } else {
        input.type = 'password';
        btn.textContent = 'Show';
      }
    }

    function censorApiKey(key) {
      if (key.length <= 8) return key;
      return key.substring(0, 4) + 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' + key.substring(key.length - 4);
    }

    // Voice sample handling
    let sampleAudio = null;
    const sampleTexts = {
      stewie: "Hi, I'm Stewie",
      peter: "Hi, I'm Peter"
    };

    async function checkSamplesExist() {
      const stewieExists = await fetch('/samples/stewie-sample.mp3', { method: 'HEAD' }).then(r => r.ok).catch(() => false);
      const peterExists = await fetch('/samples/peter-sample.mp3', { method: 'HEAD' }).then(r => r.ok).catch(() => false);
      return { stewie: stewieExists, peter: peterExists };
    }

    async function playVoiceSample(character) {
      if (sampleAudio) {
        sampleAudio.pause();
        sampleAudio = null;
      }

      const btn = character === 'stewie' ? $('#playStewieSample') : $('#playPeterSample');
      btn.textContent = '...';

      try {
        // Get currently selected voice ID
        const voiceSelect = character === 'stewie' ? $('#stewieVoice') : $('#peterVoice');
        const voiceId = voiceSelect.value;
        if (!voiceId) {
          showError('Please select a voice first');
          btn.textContent = 'â–¶';
          return;
        }

        // Try to play from server first (filename includes voice ID)
        const sampleUrl = `/samples/${character}-${voiceId}-sample.mp3`;
        const exists = await fetch(sampleUrl, { method: 'HEAD' }).then(r => r.ok).catch(() => false);

        if (exists) {
          sampleAudio = new Audio(sampleUrl);
          sampleAudio.onended = () => { btn.textContent = 'â–¶'; };
          await sampleAudio.play();
          btn.textContent = 'â¸';
        } else {
          // Generate and save sample for this specific voice
          await generateAndSaveSample(character);
          btn.textContent = 'â–¶';
        }
      } catch (err) {
        console.error('Sample playback error:', err);
        btn.textContent = 'â–¶';
        showError('Could not play sample: ' + err.message);
      }
    }

    async function generateAndSaveSample(character) {
      const apiKey = $('#apiKeyInput').value.trim();
      if (!apiKey) {
        showError('Please enter your API key first to generate voice samples');
        return;
      }

      const voiceSelect = character === 'stewie' ? $('#stewieVoice') : $('#peterVoice');
      const voiceId = voiceSelect.value;
      if (!voiceId) {
        showError('Please select a voice first');
        return;
      }

      const statusEl = $('#sampleStatus');
      statusEl.textContent = `Generating ${character} sample...`;

      try {
        const res = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
          method: 'POST',
          headers: {
            'xi-api-key': apiKey,
            'Content-Type': 'application/json',
            'Accept': 'audio/mpeg'
          },
          body: JSON.stringify({
            text: sampleTexts[character],
            model_id: 'eleven_turbo_v2_5',
            voice_settings: { stability: 0.5, similarity_boost: 0.75 }
          })
        });

        if (!res.ok) {
          const errText = await res.text();
          console.error('ElevenLabs error:', res.status, errText);
          throw new Error(`API error ${res.status}: ${errText.substring(0, 100)}`);
        }

        const audioBlob = await res.blob();

        // Save to server (include voice ID in filename for caching per voice)
        const formData = new FormData();
        formData.append('filename', `${character}-${voiceId}-sample.mp3`);
        formData.append('audio', audioBlob);

        await fetch('/save-sample', { method: 'POST', body: formData });

        // Play the sample
        sampleAudio = new Audio(URL.createObjectURL(audioBlob));
        const btn = character === 'stewie' ? $('#playStewieSample') : $('#playPeterSample');
        sampleAudio.onended = () => { btn.textContent = 'â–¶'; };
        await sampleAudio.play();
        btn.textContent = 'â¸';

        statusEl.textContent = `${character} sample saved!`;
        setTimeout(() => { statusEl.textContent = ''; }, 2000);
      } catch (err) {
        console.error('Sample generation error:', err);
        statusEl.textContent = '';
        showError('Could not generate sample: ' + err.message);
      }
    }

    async function loadVoices() {
      const apiKey = $('#apiKeyInput').value.trim();
      if (!apiKey) {
        showError('Please enter your ElevenLabs API key');
        return;
      }

      // Validate key format
      if (!apiKey.startsWith('sk_') || apiKey.length < 30) {
        showError('API key should start with "sk_" and be at least 30 characters. Please check your key.');
        return;
      }

      // Show debug info
      $('#keyDebug').textContent = `Key: ${censorApiKey(apiKey)} (${apiKey.length} chars)`;

      // Show loading state
      $('#loadVoicesBtn').textContent = 'Loading...';
      $('#loadVoicesBtn').disabled = true;

      try {
        console.log('Fetching voices with key:', apiKey.substring(0, 6) + '...');

        const res = await fetch('https://api.elevenlabs.io/v1/voices', {
          method: 'GET',
          headers: {
            'xi-api-key': apiKey,
            'Accept': 'application/json'
          }
        });

        console.log('Response status:', res.status);

        if (!res.ok) {
          const errorText = await res.text();
          console.log('Error response:', errorText);
          let errorMsg;
          try {
            const errorData = JSON.parse(errorText);
            errorMsg = errorData.detail?.message || errorData.detail || errorData.message || `HTTP ${res.status}`;
          } catch {
            errorMsg = `HTTP ${res.status}: ${res.statusText}`;
          }
          throw new Error(errorMsg);
        }

        const data = await res.json();
        state.voices = data.voices || [];

        // Auto-select default voices: Harry for Stewie, George for Peter
        const stewieVoice = state.voices.find(v =>
          v.name.toLowerCase() === 'harry'
        ) || state.voices.find(v =>
          v.name.toLowerCase().includes('harry')
        ) || state.voices[0];
        const peterVoice = state.voices.find(v =>
          v.name.toLowerCase() === 'george'
        ) || state.voices.find(v =>
          v.name.toLowerCase().includes('george')
        ) || state.voices[1] || state.voices[0];

        state.selectedVoices.stewie = stewieVoice?.voice_id || '';
        state.selectedVoices.peter = peterVoice?.voice_id || '';

        // Populate selects
        const options = state.voices.map(v =>
          `<option value="${v.voice_id}">${v.name}</option>`
        ).join('');

        $('#stewieVoice').innerHTML = options;
        $('#peterVoice').innerHTML = options;
        $('#stewieVoice').value = state.selectedVoices.stewie;
        $('#peterVoice').value = state.selectedVoices.peter;

        $('#voiceSelection').style.display = 'block';
        $('#generateBtn').disabled = false;
        hideError();

        localStorage.setItem('elevenlabs_api_key', apiKey);
      } catch (err) {
        showError(err.message);
      } finally {
        $('#loadVoicesBtn').textContent = 'Load Voices';
        $('#loadVoicesBtn').disabled = false;
      }
    }

    async function generateVoices() {
      const apiKey = $('#apiKeyInput').value.trim();
      state.selectedVoices.stewie = $('#stewieVoice').value;
      state.selectedVoices.peter = $('#peterVoice').value;

      // Filter dialogues that have content (check both modes)
      const dialoguesWithText = state.dialogues.filter(d => getAudioText(d).trim());
      if (dialoguesWithText.length === 0) {
        showError('No dialogue text to generate');
        return;
      }

      state.isGenerating = true;
      state.audioData = [];
      $('#generateBtn').innerHTML = '<span class="spinner"></span> Generating...';
      $('#generateBtn').disabled = true;
      $('#progressContainer').style.display = 'block';

      try {
        for (let i = 0; i < dialoguesWithText.length; i++) {
          const d = dialoguesWithText[i];
          updateProgress((i / dialoguesWithText.length) * 100,
            `Generating ${d.speaker}'s voice (${i + 1}/${dialoguesWithText.length})...`);

          const voiceId = state.selectedVoices[d.speaker];
          const audioText = getAudioText(d);  // Use audio script for TTS
          const captionText = getCaptionText(d);  // Store caption script for display
          const result = await generateSingleVoice(apiKey, audioText, voiceId);

          state.audioData.push({
            id: d.id,
            speaker: d.speaker,
            text: captionText,  // Store caption text for display in captions
            audioText: audioText,  // Keep audio text for reference
            ...result
          });
        }

        updateProgress(100, 'Complete!');
        renderAudioList();
        $('#toStep3Btn').disabled = false;
        hideError();
      } catch (err) {
        showError(err.message);
      } finally {
        state.isGenerating = false;
        $('#generateBtn').innerHTML = 'Generate Audio Script';
        $('#generateBtn').disabled = false;
      }
    }

    const AUDIO_SPEED = 1.5; // Play audio at 1.5x speed (applied during playback, not pre-processing)

    async function generateSingleVoice(apiKey, text, voiceId) {
      // Try with timestamps first
      console.log('Generating voice...');
      let res = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}/with-timestamps`, {
        method: 'POST',
        headers: {
          'xi-api-key': apiKey,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          text,
          model_id: 'eleven_turbo_v2_5',
          voice_settings: { stability: 0.5, similarity_boost: 0.75 }
        })
      });

      if (!res.ok) {
        // Fallback to simple endpoint
        res = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
          method: 'POST',
          headers: {
            'xi-api-key': apiKey,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text,
            model_id: 'eleven_turbo_v2_5',
            voice_settings: { stability: 0.5, similarity_boost: 0.75 }
          })
        });

        if (!res.ok) throw new Error('Voice generation failed');

        const audioBlob = await res.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        const duration = await getAudioDuration(audioUrl);
        // Adjust duration for playback speed
        const adjustedDuration = duration / AUDIO_SPEED;
        const wordTimings = estimateWordTimings(text, adjustedDuration);

        return { audioUrl, audioBlob, duration: adjustedDuration, originalDuration: duration, wordTimings };
      }

      const data = await res.json();
      const audioBytes = atob(data.audio_base64);
      const audioArray = new Uint8Array(audioBytes.length);
      for (let i = 0; i < audioBytes.length; i++) {
        audioArray[i] = audioBytes.charCodeAt(i);
      }
      const audioBlob = new Blob([audioArray], { type: 'audio/mpeg' });
      const audioUrl = URL.createObjectURL(audioBlob);
      const duration = await getAudioDuration(audioUrl);
      // Adjust duration for playback speed
      const adjustedDuration = duration / AUDIO_SPEED;

      // Adjust word timings for speed
      let wordTimings = processWordTimings(data.alignment, text) || estimateWordTimings(text, adjustedDuration);
      wordTimings = wordTimings.map(wt => ({
        ...wt,
        start: wt.start / AUDIO_SPEED,
        end: wt.end / AUDIO_SPEED
      }));

      return { audioUrl, audioBlob, duration: adjustedDuration, originalDuration: duration, wordTimings };
    }

    function getAudioDuration(url) {
      return new Promise(resolve => {
        const audio = new Audio(url);
        audio.onloadedmetadata = () => resolve(audio.duration);
        audio.onerror = () => resolve(3);
      });
    }

    function processWordTimings(alignment, text) {
      if (!alignment?.characters) return null;

      const { characters, character_start_times_seconds, character_end_times_seconds } = alignment;
      const words = [];
      let currentWord = '';
      let wordStart = null;
      let wordEnd = null;

      for (let i = 0; i < characters.length; i++) {
        const char = characters[i];
        if (char === ' ' || char === '\n') {
          if (currentWord) {
            words.push({ word: currentWord, start: wordStart, end: wordEnd });
            currentWord = '';
            wordStart = null;
          }
        } else {
          if (wordStart === null) wordStart = character_start_times_seconds[i];
          wordEnd = character_end_times_seconds[i];
          currentWord += char;
        }
      }
      if (currentWord) words.push({ word: currentWord, start: wordStart, end: wordEnd });
      return words;
    }

    function estimateWordTimings(text, duration) {
      const words = text.split(/\s+/).filter(w => w);
      const avg = duration / words.length;
      return words.map((word, i) => ({
        word,
        start: i * avg,
        end: (i + 1) * avg
      }));
    }

    function renderAudioList() {
      if (state.audioData.length === 0) {
        $('#audioList').style.display = 'none';
        return;
      }

      $('#audioList').style.display = 'block';
      $('#totalDuration').textContent = `Total: ${getTotalDuration().toFixed(1)}s`;
      $('#audioItems').innerHTML = state.audioData.map((a, i) => `
        <div class="audio-item ${a.speaker}">
          <div class="audio-index">${i + 1}</div>
          <div class="audio-speaker">${a.speaker === 'stewie' ? 'S' : 'P'}</div>
          <input type="text" class="audio-text-input" id="audioText-${a.id}" value="${(a.audioText || a.text).replace(/"/g, '&quot;')}" onchange="updateAudioText('${a.id}', this.value)" />
          <div class="audio-duration" id="duration-${a.id}">${a.duration?.toFixed(1)}s</div>
          <button class="play-btn" onclick="playAudio('${a.id}')" title="Play">â–¶</button>
          <button class="play-btn" onclick="regenerateAudio('${a.id}', this)" title="Regenerate">â†»</button>
          <button class="play-btn" onclick="downloadAudio('${a.id}', ${i + 1}, '${a.speaker}', this)" title="Download">â†“</button>
          <audio id="audio-${a.id}" src="${a.audioUrl}"></audio>
        </div>
      `).join('');
    }

    function playAudio(id) {
      // Stop all audio first
      $$('audio').forEach(a => { a.pause(); a.currentTime = 0; a.playbackRate = 1; });
      const audio = $(`#audio-${id}`);
      if (audio) {
        audio.playbackRate = AUDIO_SPEED; // Play at 1.5x speed
        audio.play();
      }
    }

    function updateAudioText(id, newText) {
      const audio = state.audioData.find(a => String(a.id) === String(id));
      if (audio) {
        audio.audioText = newText;
        // Note: audio.text (caption text) is preserved separately
      }
    }

    async function regenerateAudio(id, btn) {
      const audio = state.audioData.find(a => String(a.id) === String(id));
      if (!audio) return;

      const apiKey = $('#apiKeyInput').value.trim();
      if (!apiKey) {
        showError('Please enter your API key to regenerate');
        return;
      }

      const voiceId = state.selectedVoices[audio.speaker];
      if (!voiceId) {
        showError('Please select a voice first');
        return;
      }

      // Get the current text from input field
      const textInput = $(`#audioText-${id}`);
      const newText = textInput ? textInput.value.trim() : audio.audioText;

      if (!newText) {
        showError('Please enter text to generate');
        return;
      }

      // Show loading state
      const originalText = btn.textContent;
      btn.textContent = '...';
      btn.disabled = true;

      try {
        const result = await generateSingleVoice(apiKey, newText, voiceId);

        // Update audio data (only audioText for TTS, preserve caption text)
        audio.audioText = newText;
        audio.audioUrl = result.audioUrl;
        audio.duration = result.duration;
        audio.wordTimings = result.wordTimings;

        // Update DOM
        const audioEl = $(`#audio-${id}`);
        if (audioEl) audioEl.src = result.audioUrl;

        const durationEl = $(`#duration-${id}`);
        if (durationEl) durationEl.textContent = `${result.duration?.toFixed(1)}s`;

        // Update total duration
        $('#totalDuration').textContent = `Total: ${getTotalDuration().toFixed(1)}s`;

        btn.textContent = 'âœ“';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.disabled = false;
        }, 1000);
      } catch (err) {
        console.error('Regenerate error:', err);
        showError('Regeneration failed: ' + err.message);
        btn.textContent = 'âœ—';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.disabled = false;
        }, 1500);
      }
    }

    async function downloadAudio(id, index, speaker, btn = null) {
      const audio = state.audioData.find(a => String(a.id) === String(id));
      if (!audio || !audio.audioUrl) return;

      // Show loading state
      const originalText = btn ? btn.textContent : null;
      if (btn) {
        btn.textContent = '...';
        btn.disabled = true;
      }

      try {
        // Load FFmpeg if needed for 1.5x speed processing
        const loaded = await loadFFmpeg();
        if (!loaded) {
          throw new Error('Could not load audio processor');
        }

        // Fetch original audio
        const response = await fetch(audio.audioUrl);
        const audioBlob = await response.blob();
        const arrayBuffer = await audioBlob.arrayBuffer();

        // Write to FFmpeg
        ffmpeg.FS('writeFile', 'input.mp3', new Uint8Array(arrayBuffer));

        // Apply 1.5x speed with pitch preservation using atempo
        await ffmpeg.run(
          '-i', 'input.mp3',
          '-filter:a', `atempo=${AUDIO_SPEED}`,
          '-y', 'output.mp3'
        );

        // Read processed file
        const data = ffmpeg.FS('readFile', 'output.mp3');
        const processedBlob = new Blob([data.buffer], { type: 'audio/mpeg' });

        // Clean up
        ffmpeg.FS('unlink', 'input.mp3');
        ffmpeg.FS('unlink', 'output.mp3');

        // Download
        const link = document.createElement('a');
        link.href = URL.createObjectURL(processedBlob);
        link.download = `${String(index).padStart(2, '0')}_${speaker}_1.5x.mp3`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        // Brief success indicator
        if (btn) {
          btn.textContent = 'âœ“';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.disabled = false;
          }, 1000);
        }
      } catch (err) {
        console.error('Download error:', err);
        if (btn) {
          btn.textContent = 'âœ—';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.disabled = false;
          }, 1500);
        }
      }
    }

    async function downloadAllAudio() {
      if (!state.audioData || state.audioData.length === 0) return;

      const btn = document.querySelector('[onclick="downloadAllAudio()"]');
      const originalText = btn ? btn.textContent : null;
      if (btn) {
        btn.innerHTML = 'Downloading...';
        btn.disabled = true;
      }

      // Download each file with a small delay to avoid browser blocking
      for (let i = 0; i < state.audioData.length; i++) {
        const a = state.audioData[i];
        await downloadAudio(a.id, i + 1, a.speaker);
        await new Promise(r => setTimeout(r, 300));
      }

      if (btn) {
        btn.innerHTML = 'âœ“ Done!';
        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.disabled = false;
        }, 1500);
      }
    }

    // ========== ASPECT RATIO ==========
    function selectRatio(ratio) {
      state.aspectRatio = ratio;
      $$('.ratio-card').forEach(card => {
        card.classList.remove('selected');
        card.querySelector('.selected-badge')?.remove();
        if (card.dataset.ratio === ratio) {
          card.classList.add('selected');
          card.innerHTML += '<div class="selected-badge">âœ“</div>';
        }
      });
    }

    // ========== PREVIEW ==========
    let animationId = null;
    let previewStartTime = null;

    function setupPreview() {
      const canvas = $('#previewCanvas');
      const ratio = ASPECT_RATIOS[state.aspectRatio];
      // Scale to fit within 540x540 container (1:1 fills it, others fit inside)
      const containerSize = 540;
      const scale = Math.min(containerSize / ratio.width, containerSize / ratio.height);
      canvas.width = ratio.width * scale;
      canvas.height = ratio.height * scale;

      $('#previewRatio').textContent = state.aspectRatio;
      $('#exportDuration').textContent = `${getTotalDuration().toFixed(1)}s`;
      $('#exportResolution').textContent = `${ratio.width}Ã—${ratio.height}`;
      $('#exportDialogues').textContent = state.audioData.length;

      state.currentTime = 0;
      state.isPlaying = false;

      // Set video to start position and wait for it to be ready before drawing
      if (backgroundVideo && backgroundVideo.readyState >= 2) {
        backgroundVideo.currentTime = bgVideoStartTime;
        // Wait for seek to complete before drawing first frame
        backgroundVideo.onseeked = () => {
          drawPreviewFrame(0);
        };
        // Fallback if onseeked doesn't fire
        setTimeout(() => drawPreviewFrame(0), 100);
      } else {
        drawPreviewFrame(0);
      }
    }

    function drawFrame(time, targetCanvas = null) {
      const canvas = targetCanvas || $('#previewCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const isPreview = !targetCanvas; // Update UI only for preview

      // Enable high quality image smoothing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      const timings = getDialogueTimings();
      const currentDialogue = timings.find(d => time >= d.start && time < d.end) || timings[0];
      const isStewie = currentDialogue?.speaker === 'stewie';

      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      // Draw video background (cover fit) or fallback gradient
      if (backgroundVideo && backgroundVideo.readyState >= 2) {
        const videoAspect = backgroundVideo.videoWidth / backgroundVideo.videoHeight;
        const canvasAspect = width / height;
        let drawW, drawH, drawX, drawY;
        if (videoAspect > canvasAspect) {
          drawH = height;
          drawW = height * videoAspect;
          drawX = (width - drawW) / 2;
          drawY = 0;
        } else {
          drawW = width;
          drawH = width / videoAspect;
          drawX = 0;
          drawY = (height - drawH) / 2;
        }
        ctx.drawImage(backgroundVideo, drawX, drawY, drawW, drawH);
      } else {
        // Fallback gradient if no video
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
      }

      // Character image
      const charImg = isStewie ? characterImages.stewie : characterImages.peter;
      if (charImg) {
        // Scale image to fit nicely in the frame
        const maxCharHeight = height * 0.5;
        const maxCharWidth = width * 0.6;
        let scale = Math.min(maxCharHeight / charImg.height, maxCharWidth / charImg.width);

        // Scale up Peter by 30%
        if (!isStewie) {
          scale *= 1.3;
        }

        const charW = charImg.width * scale;
        const charH = charImg.height * scale;

        // Position: Stewie 10% left of center, Peter 10% right of center
        const offsetX = width * 0.1;
        let charX;
        if (isStewie) {
          charX = (width - charW) / 2 - offsetX; // Left of center
        } else {
          charX = (width - charW) / 2 + offsetX; // Right of center
        }
        let charY = height - charH - (height * 0.05);
        // Move Peter down to align heads
        if (!isStewie) {
          charY += height * 0.08;
        }

        // CapCut-style shake effect: speed 5, intensity 4 (mostly vertical)
        // Only shake when character is actively speaking
        const isCurrentlySpeaking = currentDialogue && time >= currentDialogue.start && time < currentDialogue.end;
        let shakeX = 0, shakeY = 0;
        if (isCurrentlySpeaking) {
          const shakeSpeed = 5;
          const shakeIntensity = 4;
          const shakeTime = performance.now() / 1000;
          shakeX = Math.sin(shakeTime * shakeSpeed * 2 * Math.PI) * shakeIntensity * 0.2; // Minimal horizontal
          shakeY = Math.cos(shakeTime * shakeSpeed * 2 * Math.PI) * shakeIntensity; // Full vertical
        }

        // Flip Peter horizontally so he faces left
        if (!isStewie) {
          ctx.save();
          ctx.translate(charX + charW + shakeX, charY + shakeY);
          ctx.scale(-1, 1);
          ctx.drawImage(charImg, 0, 0, charW, charH);
          ctx.restore();
        } else {
          ctx.drawImage(charImg, charX + shakeX, charY + shakeY, charW, charH);
        }
      } else {
        // Fallback to emoji if image not loaded
        ctx.fillStyle = isStewie ? '#FBBF24' : '#22C55E';
        const charY = height * 0.65;
        ctx.beginPath();
        ctx.ellipse(width / 2, charY, 40, 50, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(isStewie ? 'S' : 'P', width / 2, charY + 10);
      }

      // Karaoke captions
      if (currentDialogue?.text) {
        const relTime = time - currentDialogue.start;
        drawKaraokeCaption(ctx, currentDialogue, relTime, width, height, isStewie);
      }

      // Update UI only for preview
      if (isPreview) {
        const total = getTotalDuration();
        $('#timeDisplay').textContent = `${formatTime(time)} / ${formatTime(total)}`;
        $('#previewProgressFill').style.width = `${(time / total) * 100}%`;
      }
    }

    // Alias for backward compatibility
    function drawPreviewFrame(time) {
      drawFrame(time);
    }

    function drawKaraokeCaption(ctx, dialogue, relTime, width, height, isStewie = true) {
      // Split into words, track which ones end with sentence break (., !, ?, or comma)
      const rawWords = dialogue.text.split(/\s+/);
      // Sentence breaks: period (not decimal), !, ?, or comma (comma is separator but hidden)
      const sentenceBreaks = rawWords.map(w => /[.!?,]$/.test(w) && !/\d\.\d/.test(w));

      // Clean words: uppercase and selectively remove special characters
      // Keep: letters, numbers, apostrophes, quotes, %, ?, and decimal points (digit.digit)
      const words = rawWords.map(w => {
        let cleaned = w.toUpperCase();
        // Preserve decimal points (e.g., 3.14) by temporarily replacing
        cleaned = cleaned.replace(/(\d)\.(\d)/g, '$1DECIMAL$2');
        // Remove unwanted characters but keep %, ?, apostrophes, quotes
        cleaned = cleaned.replace(/[^A-Z0-9'"'%?DECIMAL]/g, '');
        // Restore decimal points
        cleaned = cleaned.replace(/DECIMAL/g, '.');
        // Remove trailing punctuation (period, comma) but keep ? and %
        cleaned = cleaned.replace(/[.,]$/, '');
        return cleaned;
      }).filter(w => w.length > 0);
      const wordTimings = dialogue.wordTimings || [];

      if (words.length === 0) return;

      // Find current word index - clamp to valid range and don't loop
      let currentWordIndex = 0;
      if (wordTimings.length > 0) {
        for (let i = 0; i < wordTimings.length; i++) {
          if (relTime >= wordTimings[i].start) currentWordIndex = i;
        }
        // Clamp to last word - don't loop
        currentWordIndex = Math.min(currentWordIndex, words.length - 1);
      } else {
        const wps = words.length / (dialogue.duration || 2);
        currentWordIndex = Math.min(Math.floor(relTime * wps), words.length - 1);
      }

      // Build groups of 3, but sentence breaks (., !, ?) start new group
      const groups = [];
      let currentGroup = [];
      for (let i = 0; i < words.length; i++) {
        currentGroup.push({ word: words[i], originalIndex: i });
        if (currentGroup.length === 3 || sentenceBreaks[i] || i === words.length - 1) {
          groups.push(currentGroup);
          currentGroup = [];
        }
      }

      // Find which group contains the current word - stay on last group at end
      let groupIndex = groups.length - 1; // Default to last group
      let wordIndexInGroup = 0;
      let wordCount = 0;
      for (let g = 0; g < groups.length; g++) {
        if (currentWordIndex < wordCount + groups[g].length) {
          groupIndex = g;
          wordIndexInGroup = currentWordIndex - wordCount;
          break;
        }
        wordCount += groups[g].length;
      }

      // Ensure wordIndexInGroup is valid for the group
      const visibleGroup = groups[groupIndex] || groups[0] || [];
      wordIndexInGroup = Math.min(wordIndexInGroup, visibleGroup.length - 1);
      const visibleWords = visibleGroup.map(w => w.word);

      // Large bold font for impact - scale proportionally to canvas size
      const fontSize = width * 0.08;
      ctx.font = `900 ${fontSize}px Inter, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const maxWidth = width * 0.9;
      const doubleSpaceWidth = ctx.measureText('  ').width;

      // Word-wrap visible words into lines that fit (using double spacing)
      const lines = [];
      let currentLine = [];
      let currentLineWordIndices = [];
      let lineWidth = 0;

      visibleWords.forEach((word, i) => {
        const wordWidth = ctx.measureText(word).width + doubleSpaceWidth;
        if (lineWidth + wordWidth > maxWidth && currentLine.length > 0) {
          lines.push({ words: currentLine, indices: currentLineWordIndices });
          currentLine = [word];
          currentLineWordIndices = [i];
          lineWidth = wordWidth;
        } else {
          currentLine.push(word);
          currentLineWordIndices.push(i);
          lineWidth += wordWidth;
        }
      });
      if (currentLine.length > 0) {
        lines.push({ words: currentLine, indices: currentLineWordIndices });
      }

      // Draw lines centered - position varies by aspect ratio
      const lineHeight = fontSize * 1.2;
      // Calculate aspect ratio to adjust position (lower by 10% for 16:9 and 9:16)
      const aspectRatio = width / height;
      const is1to1 = Math.abs(aspectRatio - 1) < 0.1;
      const startY = is1to1 ? height * 0.22 : height * 0.32;  // 10% lower for non-square

      // Double spacing between words to prevent overlap with scaled words
      const wordSpacing = ctx.measureText('  ').width;  // Double space width

      // Highlight color: yellow for Stewie, green for Peter
      const highlightColor = isStewie ? '#FFEB3B' : '#00FF00';

      lines.forEach((line, lineNum) => {
        // Use double spacing between words
        const lineText = line.words.join('  ');
        const lineTextWidth = ctx.measureText(lineText).width;
        let x = (width - lineTextWidth) / 2;
        const y = startY + lineNum * lineHeight;

        line.words.forEach((word, wordIdx) => {
          const wordWidth = ctx.measureText(word).width;
          const wordX = x + wordWidth / 2;
          const isCurrentWord = line.indices[wordIdx] === wordIndexInGroup;

          // Scale up highlighted word by 15%
          const scale = isCurrentWord ? 1.15 : 1.0;
          const currentFontSize = fontSize * scale;

          if (isCurrentWord) {
            ctx.font = `900 ${currentFontSize}px Inter, Arial`;
          }

          // Drop shadow
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillText(word, wordX + 3, y + 3);

          // Draw outline (doubled thickness)
          ctx.strokeStyle = 'rgba(0,0,0,0.8)';
          ctx.lineWidth = currentFontSize * 0.24;
          ctx.lineJoin = 'round';
          ctx.strokeText(word, wordX, y);

          // Draw word - highlight color for current, white for others
          ctx.fillStyle = isCurrentWord ? highlightColor : '#FFFFFF';
          ctx.fillText(word, wordX, y);

          // Reset font if we changed it
          if (isCurrentWord) {
            ctx.font = `900 ${fontSize}px Inter, Arial`;
          }

          // Double spacing between words
          x += wordWidth + wordSpacing;
        });
      });
    }

    async function togglePlayback() {
      if (state.isPlaying) {
        state.isPlaying = false;
        cancelAnimationFrame(animationId);
        $$('audio').forEach(a => { a.pause(); a.currentTime = 0; });
        if (backgroundVideo) backgroundVideo.pause();
        $('#playPauseBtn').textContent = 'â–¶';
      } else {
        $('#playPauseBtn').textContent = 'â¸';

        // Start background video and wait for it to be ready
        if (backgroundVideo) {
          backgroundVideo.currentTime = bgVideoStartTime + state.currentTime;
          // Wait for video to seek and be ready to play
          await new Promise(resolve => {
            const onSeeked = () => {
              backgroundVideo.removeEventListener('seeked', onSeeked);
              resolve();
            };
            backgroundVideo.addEventListener('seeked', onSeeked);
            setTimeout(resolve, 150); // Fallback timeout
          });
          backgroundVideo.play().catch(() => {});
          // Small delay to ensure video is actually playing
          await new Promise(r => setTimeout(r, 50));
        }

        state.isPlaying = true;
        previewStartTime = performance.now() - state.currentTime * 1000;

        // Start audio playback at 1.5x speed
        const timings = getDialogueTimings();
        timings.forEach(t => {
          const audio = $(`#audio-${t.id}`);
          if (audio && t.start >= state.currentTime) {
            setTimeout(() => {
              if (state.isPlaying) {
                audio.playbackRate = AUDIO_SPEED;
                audio.play().catch(() => {});
              }
            }, (t.start - state.currentTime) * 1000);
          }
        });

        animate();
      }
    }

    function animate() {
      const elapsed = (performance.now() - previewStartTime) / 1000;
      const total = getTotalDuration();

      if (elapsed >= total) {
        state.isPlaying = false;
        state.currentTime = 0;
        $('#playPauseBtn').textContent = 'â–¶';
        drawPreviewFrame(0);
        return;
      }

      state.currentTime = elapsed;
      drawPreviewFrame(elapsed);
      animationId = requestAnimationFrame(animate);
    }

    function restart() {
      state.isPlaying = false;
      state.currentTime = 0;
      cancelAnimationFrame(animationId);
      $$('audio').forEach(a => { a.pause(); a.currentTime = 0; });
      if (backgroundVideo) {
        backgroundVideo.pause();
        backgroundVideo.currentTime = bgVideoStartTime;
      }
      $('#playPauseBtn').textContent = 'â–¶';
      drawPreviewFrame(0);
    }

    // ========== VIDEO POPUP PLAYER ==========
    let popupAnimationId = null;
    let popupStartTime = null;
    let popupIsPlaying = false;
    let popupCurrentTime = 0;
    let popupAudioTimeouts = []; // Track all scheduled audio timeouts
    let popupAutoplayTimeout = null; // Track autoplay timeout

    function clearAllPopupTimeouts() {
      // Clear all scheduled audio timeouts
      popupAudioTimeouts.forEach(id => clearTimeout(id));
      popupAudioTimeouts = [];
      // Clear autoplay timeout
      if (popupAutoplayTimeout) {
        clearTimeout(popupAutoplayTimeout);
        popupAutoplayTimeout = null;
      }
    }

    function openVideoPopup() {
      // First, make sure everything is fully stopped and reset
      clearAllPopupTimeouts();
      cancelAnimationFrame(popupAnimationId);
      $$('audio').forEach(a => { a.pause(); a.currentTime = 0; });
      if (backgroundVideo) backgroundVideo.pause();

      const overlay = $('#videoModalOverlay');
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden'; // Prevent background scrolling

      // Setup popup canvas with same dimensions as preview
      const popupCanvas = $('#popupPreviewCanvas');
      const ratio = ASPECT_RATIOS[state.aspectRatio];

      // Scale to fit popup (max ~380px)
      const maxSize = 380;
      const scale = Math.min(maxSize / ratio.width, maxSize / ratio.height);
      popupCanvas.width = ratio.width * scale;
      popupCanvas.height = ratio.height * scale;

      // Update ratio display
      $('#popupRatioDisplay').textContent = state.aspectRatio;

      // Reset time and state
      popupCurrentTime = 0;
      popupIsPlaying = false;
      $('#popupPlayPauseBtn').innerHTML = '&#9658;';
      $('.video-popup-status-text').textContent = 'Ready';

      // Draw first frame
      drawPopupFrame(0);

      // AUTO-PLAY after short delay
      popupAutoplayTimeout = setTimeout(() => {
        if ($('#videoModalOverlay').classList.contains('active')) {
          startPopupPlayback();
        }
      }, 300);
    }

    function closeVideoPopup() {
      stopPopupPlayback();
      clearAllPopupTimeouts();
      const overlay = $('#videoModalOverlay');
      overlay.classList.remove('active');
      document.body.style.overflow = ''; // Restore scrolling
    }

    function drawPopupFrame(time) {
      const popupCanvas = $('#popupPreviewCanvas');
      const ctx = popupCanvas.getContext('2d');
      const width = popupCanvas.width;
      const height = popupCanvas.height;

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      const timings = getDialogueTimings();
      const currentDialogue = timings.find(d => time >= d.start && time < d.end) || timings[0];
      const isStewie = currentDialogue?.speaker === 'stewie';

      ctx.clearRect(0, 0, width, height);

      // Draw video background
      if (backgroundVideo && backgroundVideo.readyState >= 2) {
        const videoAspect = backgroundVideo.videoWidth / backgroundVideo.videoHeight;
        const canvasAspect = width / height;
        let drawW, drawH, drawX, drawY;
        if (videoAspect > canvasAspect) {
          drawH = height;
          drawW = height * videoAspect;
          drawX = (width - drawW) / 2;
          drawY = 0;
        } else {
          drawW = width;
          drawH = width / videoAspect;
          drawX = 0;
          drawY = (height - drawH) / 2;
        }
        ctx.drawImage(backgroundVideo, drawX, drawY, drawW, drawH);
      } else {
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
      }

      // Character image
      const charImg = isStewie ? characterImages.stewie : characterImages.peter;
      if (charImg) {
        const maxCharHeight = height * 0.5;
        const maxCharWidth = width * 0.6;
        let scale = Math.min(maxCharHeight / charImg.height, maxCharWidth / charImg.width);
        if (!isStewie) scale *= 1.3;

        const charW = charImg.width * scale;
        const charH = charImg.height * scale;
        const offsetX = width * 0.1;
        let charX = isStewie ? (width - charW) / 2 - offsetX : (width - charW) / 2 + offsetX;
        let charY = height - charH - (height * 0.05);
        if (!isStewie) charY += height * 0.08;

        const isCurrentlySpeaking = currentDialogue && time >= currentDialogue.start && time < currentDialogue.end;
        let shakeX = 0, shakeY = 0;
        if (isCurrentlySpeaking) {
          const shakeSpeed = 5;
          const shakeIntensity = 4;
          const shakeTime = performance.now() / 1000;
          shakeX = Math.sin(shakeTime * shakeSpeed * 2 * Math.PI) * shakeIntensity * 0.2;
          shakeY = Math.cos(shakeTime * shakeSpeed * 2 * Math.PI) * shakeIntensity;
        }

        if (!isStewie) {
          ctx.save();
          ctx.translate(charX + charW + shakeX, charY + shakeY);
          ctx.scale(-1, 1);
          ctx.drawImage(charImg, 0, 0, charW, charH);
          ctx.restore();
        } else {
          ctx.drawImage(charImg, charX + shakeX, charY + shakeY, charW, charH);
        }
      }

      // Karaoke captions
      if (currentDialogue?.text) {
        const relTime = time - currentDialogue.start;
        drawKaraokeCaption(ctx, currentDialogue, relTime, width, height, isStewie);
      }

      // Update popup UI
      const total = getTotalDuration();
      const formatPopupTime = (s) => {
        const mins = Math.floor(s / 60);
        const secs = Math.floor(s % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
      };
      $('#popupTimeDisplay').textContent = `${formatPopupTime(time)} / ${formatPopupTime(total)}`;
      $('#popupProgressFill').style.width = `${(time / total) * 100}%`;
    }

    async function startPopupPlayback() {
      if (popupIsPlaying) return;

      popupIsPlaying = true;
      $('#popupPlayPauseBtn').innerHTML = '&#10074;&#10074;';
      $('.video-popup-status-text').textContent = 'Playing...';

      // Start background video
      if (backgroundVideo) {
        backgroundVideo.currentTime = bgVideoStartTime + popupCurrentTime;
        await new Promise(resolve => {
          const onSeeked = () => {
            backgroundVideo.removeEventListener('seeked', onSeeked);
            resolve();
          };
          backgroundVideo.addEventListener('seeked', onSeeked);
          setTimeout(resolve, 150);
        });
        backgroundVideo.play().catch(() => {});
        await new Promise(r => setTimeout(r, 50));
      }

      popupStartTime = performance.now() - popupCurrentTime * 1000;

      // Clear any existing audio timeouts before scheduling new ones
      clearAllPopupTimeouts();

      // Start audio with tracked timeouts
      const timings = getDialogueTimings();
      timings.forEach(t => {
        const audio = $(`#audio-${t.id}`);
        if (audio && t.start >= popupCurrentTime) {
          const timeoutId = setTimeout(() => {
            if (popupIsPlaying) {
              audio.playbackRate = AUDIO_SPEED;
              audio.play().catch(() => {});
            }
          }, (t.start - popupCurrentTime) * 1000);
          popupAudioTimeouts.push(timeoutId);
        }
      });

      animatePopup();
    }

    function stopPopupPlayback() {
      popupIsPlaying = false;
      clearAllPopupTimeouts();
      cancelAnimationFrame(popupAnimationId);
      $$('audio').forEach(a => { a.pause(); a.currentTime = 0; });
      if (backgroundVideo) backgroundVideo.pause();
      $('#popupPlayPauseBtn').innerHTML = '&#9658;';
      $('.video-popup-status-text').textContent = 'Stopped';
    }

    function togglePopupPlayback() {
      if (popupIsPlaying) {
        stopPopupPlayback();
        $('.video-popup-status-text').textContent = 'Paused';
      } else {
        startPopupPlayback();
      }
    }

    function animatePopup() {
      const elapsed = (performance.now() - popupStartTime) / 1000;
      const total = getTotalDuration();

      if (elapsed >= total) {
        popupIsPlaying = false;
        popupCurrentTime = 0;
        clearAllPopupTimeouts();
        cancelAnimationFrame(popupAnimationId);
        $('#popupPlayPauseBtn').innerHTML = '&#9658;';
        $('.video-popup-status-text').textContent = 'Finished';
        $$('audio').forEach(a => { a.pause(); a.currentTime = 0; });
        if (backgroundVideo) backgroundVideo.pause();
        drawPopupFrame(0);
        return;
      }

      popupCurrentTime = elapsed;
      drawPopupFrame(elapsed);
      popupAnimationId = requestAnimationFrame(animatePopup);
    }

    function popupStop() {
      stopPopupPlayback();
      popupCurrentTime = 0;
      if (backgroundVideo) backgroundVideo.currentTime = bgVideoStartTime;
      drawPopupFrame(0);
      $('.video-popup-status-text').textContent = 'Stopped';
    }

    function reschedulePopupAudio() {
      // Clear existing timeouts and reschedule from current position
      clearAllPopupTimeouts();
      $$('audio').forEach(a => { a.pause(); a.currentTime = 0; });

      const timings = getDialogueTimings();
      timings.forEach(t => {
        const audio = $(`#audio-${t.id}`);
        if (audio && t.start >= popupCurrentTime) {
          const timeoutId = setTimeout(() => {
            if (popupIsPlaying) {
              audio.playbackRate = AUDIO_SPEED;
              audio.play().catch(() => {});
            }
          }, (t.start - popupCurrentTime) * 1000);
          popupAudioTimeouts.push(timeoutId);
        }
      });
    }

    function popupRewind() {
      popupCurrentTime = Math.max(0, popupCurrentTime - 5);
      if (backgroundVideo) backgroundVideo.currentTime = bgVideoStartTime + popupCurrentTime;
      if (!popupIsPlaying) {
        drawPopupFrame(popupCurrentTime);
      } else {
        popupStartTime = performance.now() - popupCurrentTime * 1000;
        reschedulePopupAudio();
      }
    }

    function popupForward() {
      const total = getTotalDuration();
      popupCurrentTime = Math.min(total - 0.1, popupCurrentTime + 5);
      if (backgroundVideo) backgroundVideo.currentTime = bgVideoStartTime + popupCurrentTime;
      if (!popupIsPlaying) {
        drawPopupFrame(popupCurrentTime);
      } else {
        popupStartTime = performance.now() - popupCurrentTime * 1000;
        reschedulePopupAudio();
      }
    }

    function seekPopupVideo(event) {
      const rect = event.currentTarget.getBoundingClientRect();
      const percent = (event.clientX - rect.left) / rect.width;
      const total = getTotalDuration();
      popupCurrentTime = percent * total;
      if (backgroundVideo) backgroundVideo.currentTime = bgVideoStartTime + popupCurrentTime;
      if (!popupIsPlaying) {
        drawPopupFrame(popupCurrentTime);
      } else {
        popupStartTime = performance.now() - popupCurrentTime * 1000;
        reschedulePopupAudio();
      }
    }

    // Close popup on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && $('#videoModalOverlay').classList.contains('active')) {
        closeVideoPopup();
      }
    });

    // ========== EXPORT (FFmpeg.wasm - Frame-by-Frame) ==========
    let ffmpeg = null;
    let ffmpegLoaded = false;
    const EXPORT_FPS = 30;

    async function loadFFmpeg() {
      if (ffmpegLoaded) return true;

      try {
        console.log('Starting FFmpeg load (v0.10.x)...');

        // v0.10.x API: createFFmpeg() function
        const { createFFmpeg, fetchFile } = FFmpeg;
        window.fetchFile = fetchFile; // Make available globally for later use

        ffmpeg = createFFmpeg({
          log: true,
          corePath: 'ffmpeg/ffmpeg-core.js',
          progress: ({ ratio }) => {
            const percent = Math.round(ratio * 100);
            // Encoding happens in the 68-92% range
            updateExportProgress(68 + percent * 0.24, `Encoding: ${percent}%`);
          }
        });

        console.log('FFmpeg instance created');
        updateExportProgress(5, 'Loading FFmpeg core (~25MB)...');

        // Load with timeout
        const loadPromise = ffmpeg.load();
        const timeoutPromise = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('FFmpeg load timeout (90s). Check your network.')), 90000)
        );

        await Promise.race([loadPromise, timeoutPromise]);

        ffmpegLoaded = true;
        console.log('FFmpeg loaded successfully');
        return true;
      } catch (err) {
        console.error('Failed to load FFmpeg:', err);
        showError('FFmpeg load failed: ' + err.message);
        return false;
      }
    }

    // Helper: Seek video and wait for it to be ready (with proper frame decoding)
    function seekVideoToTime(video, time) {
      return new Promise((resolve) => {
        if (!video || video.readyState < 2) {
          resolve();
          return;
        }

        const onSeeked = () => {
          video.removeEventListener('seeked', onSeeked);
          // Wait a bit for the frame to be fully decoded
          setTimeout(resolve, 30);
        };

        video.addEventListener('seeked', onSeeked);
        video.currentTime = time;

        // Fallback timeout (longer for reliability)
        setTimeout(() => {
          video.removeEventListener('seeked', onSeeked);
          resolve();
        }, 200);
      });
    }

    // Alternative: Extract video frames by playing and capturing at intervals
    async function extractVideoFrames(video, startTime, duration, fps, progressCallback) {
      const frames = [];
      const totalFrames = Math.ceil(duration * fps);
      const frameInterval = 1 / fps;

      // Reset video to start
      video.currentTime = startTime;
      await new Promise(r => {
        video.onseeked = r;
        setTimeout(r, 500);
      });

      // Create a canvas for frame extraction
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = video.videoWidth;
      tempCanvas.height = video.videoHeight;
      const tempCtx = tempCanvas.getContext('2d');

      for (let i = 0; i < totalFrames; i++) {
        const targetTime = startTime + (i * frameInterval);

        // Seek to target time
        video.currentTime = targetTime;

        // Wait for seek and frame decode
        await new Promise(r => {
          const done = () => {
            video.removeEventListener('seeked', done);
            // Extra wait for frame decode
            setTimeout(r, 20);
          };
          video.addEventListener('seeked', done);
          setTimeout(r, 150); // Fallback
        });

        // Capture frame
        tempCtx.drawImage(video, 0, 0);

        // Store frame data
        frames.push({
          imageData: tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height),
          time: targetTime - startTime
        });

        if (progressCallback && i % 10 === 0) {
          progressCallback(i, totalFrames);
        }
      }

      return frames;
    }

    // Helper: Draw a single frame at a specific time (for export, no shake animation tied to real time)
    function drawExportFrameAtTime(ctx, time, width, height, exportVideo, timings, frameIndex) {
      // Enable high quality
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      const currentDialogue = timings.find(d => time >= d.start && time < d.end) || timings[0];
      const isStewie = currentDialogue?.speaker === 'stewie';

      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      // Draw video background (cover fit)
      if (exportVideo && exportVideo.readyState >= 2) {
        const videoAspect = exportVideo.videoWidth / exportVideo.videoHeight;
        const canvasAspect = width / height;
        let drawW, drawH, drawX, drawY;
        if (videoAspect > canvasAspect) {
          drawH = height;
          drawW = height * videoAspect;
          drawX = (width - drawW) / 2;
          drawY = 0;
        } else {
          drawW = width;
          drawH = width / videoAspect;
          drawX = 0;
          drawY = (height - drawH) / 2;
        }
        ctx.drawImage(exportVideo, drawX, drawY, drawW, drawH);
      } else {
        // Fallback gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
      }

      // Character image
      const charImg = isStewie ? characterImages.stewie : characterImages.peter;
      if (charImg) {
        const maxCharHeight = height * 0.5;
        const maxCharWidth = width * 0.6;
        let scale = Math.min(maxCharHeight / charImg.height, maxCharWidth / charImg.width);
        if (!isStewie) scale *= 1.3;

        const charW = charImg.width * scale;
        const charH = charImg.height * scale;
        const offsetX = width * 0.1;
        let charX = isStewie ? (width - charW) / 2 - offsetX : (width - charW) / 2 + offsetX;
        let charY = height - charH - (height * 0.05);
        if (!isStewie) charY += height * 0.08;

        // Deterministic shake based on frame index (not real time)
        const isCurrentlySpeaking = currentDialogue && time >= currentDialogue.start && time < currentDialogue.end;
        let shakeX = 0, shakeY = 0;
        if (isCurrentlySpeaking) {
          const shakeSpeed = 5;
          const shakeIntensity = 4;
          const shakeTime = frameIndex / EXPORT_FPS; // Use frame-based time
          shakeX = Math.sin(shakeTime * shakeSpeed * 2 * Math.PI) * shakeIntensity * 0.2;
          shakeY = Math.cos(shakeTime * shakeSpeed * 2 * Math.PI) * shakeIntensity;
        }

        if (!isStewie) {
          ctx.save();
          ctx.translate(charX + charW + shakeX, charY + shakeY);
          ctx.scale(-1, 1);
          ctx.drawImage(charImg, 0, 0, charW, charH);
          ctx.restore();
        } else {
          ctx.drawImage(charImg, charX + shakeX, charY + shakeY, charW, charH);
        }
      }

      // Karaoke captions
      if (currentDialogue?.text) {
        const relTime = time - currentDialogue.start;
        drawKaraokeCaption(ctx, currentDialogue, relTime, width, height, isStewie);
      }
    }

    // Helper: Convert canvas to PNG blob (lossless - preserves exact colors)
    function canvasToPngBlob(canvas) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve, 'image/png');
      });
    }

    // Helper: Concatenate audio buffers with timing (at ORIGINAL speed - FFmpeg atempo will speed up)
    async function createMixedAudio(audioCtx, audioData, timings, totalDuration) {
      // Calculate total duration at ORIGINAL speed (before 1.5x speedup)
      // timings are adjusted, so multiply back to get original timing
      const originalDuration = totalDuration * AUDIO_SPEED;
      const sampleRate = audioCtx.sampleRate;
      const totalSamples = Math.ceil(originalDuration * sampleRate);
      const outputBuffer = audioCtx.createBuffer(2, totalSamples, sampleRate);

      for (let i = 0; i < audioData.length; i++) {
        const audio = audioData[i];
        const timing = timings[i];

        if (!audio.audioBlob) continue;

        try {
          const arrayBuffer = await audio.audioBlob.arrayBuffer();
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

          // Calculate start position at ORIGINAL timing (multiply by speed to get original time)
          const originalStartTime = timing.start * AUDIO_SPEED;
          const startSample = Math.floor(originalStartTime * sampleRate);

          // Copy audio data WITHOUT speed adjustment (FFmpeg atempo will handle pitch-preserving speedup)
          for (let ch = 0; ch < Math.min(audioBuffer.numberOfChannels, 2); ch++) {
            const sourceData = audioBuffer.getChannelData(ch);
            const destData = outputBuffer.getChannelData(ch);

            // Simple copy - no resampling, preserves original pitch
            for (let s = 0; s < sourceData.length; s++) {
              const destIndex = startSample + s;
              if (destIndex < totalSamples) {
                destData[destIndex] += sourceData[s];
              }
            }
          }
        } catch (err) {
          console.warn('Failed to decode audio for dialogue', i, err);
        }
      }

      return outputBuffer;
    }

    async function handleExport() {
      $('#exportBtn').innerHTML = '<span class="spinner"></span> Exporting...';
      $('#exportBtn').disabled = true;
      $('#exportProgress').style.display = 'block';

      // Disable navigation during export
      $$('.step-btn').forEach(btn => btn.disabled = true);
      $('#backToStep3').disabled = true;

      // CRITICAL: Stop preview animation to prevent conflict with export
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      if (backgroundVideo) {
        backgroundVideo.pause();
      }

      try {
        // Load FFmpeg first
        updateExportProgress(2, 'Loading FFmpeg...');
        const loaded = await loadFFmpeg();
        if (!loaded) {
          throw new Error('Failed to load FFmpeg. Please refresh and try again.');
        }

        const ratio = ASPECT_RATIOS[state.aspectRatio];
        const totalDuration = getTotalDuration();
        const timings = getDialogueTimings();
        const totalFrames = Math.ceil(totalDuration * EXPORT_FPS);

        // Randomize start position within the current video (same video as preview)
        if (backgroundVideo && backgroundVideo.duration) {
          const videoDuration = totalDuration / AUDIO_SPEED;
          const maxStart = Math.max(0, backgroundVideo.duration - videoDuration - 2);
          bgVideoStartTime = Math.random() * maxStart;
          console.log('Export using:', backgroundVideo.src, 'starting at', bgVideoStartTime.toFixed(1) + 's');
        }

        updateExportProgress(5, 'Setting up export canvas...');

        // Create full resolution export canvas
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = ratio.width;
        exportCanvas.height = ratio.height;
        const exportCtx = exportCanvas.getContext('2d');

        // REUSE the already-loaded background video element (more reliable than creating new)
        const exportVideo = backgroundVideo;
        let videoReady = false;

        if (exportVideo && exportVideo.readyState >= 2 && exportVideo.videoWidth > 0) {
          updateExportProgress(7, 'Preparing background video...');

          // Pause and seek to start
          exportVideo.pause();
          exportVideo.currentTime = bgVideoStartTime;

          // Wait for seek to complete with multiple fallbacks
          await new Promise(resolve => {
            let resolved = false;
            const done = () => {
              if (!resolved) {
                resolved = true;
                resolve();
              }
            };
            exportVideo.addEventListener('seeked', done, { once: true });
            setTimeout(done, 800);
          });

          // Extra wait for frame decode
          await new Promise(r => setTimeout(r, 100));

          videoReady = exportVideo.readyState >= 2 && exportVideo.videoWidth > 0;
          console.log('Export video ready:', videoReady, exportVideo.videoWidth + 'x' + exportVideo.videoHeight, 'at time:', exportVideo.currentTime);
        } else {
          console.warn('Background video not available for export:', exportVideo?.readyState, exportVideo?.videoWidth);
        }

        updateExportProgress(10, 'Preparing audio...');

        // Create mixed audio using Web Audio API (at ORIGINAL speed)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
        const mixedAudioBuffer = await createMixedAudio(audioCtx, state.audioData, timings, totalDuration);

        // Convert audio buffer to WAV (this is at original speed, longer than video)
        const wavData = audioBufferToWav(mixedAudioBuffer);
        ffmpeg.FS('writeFile', 'audio_original.wav', new Uint8Array(wavData));
        audioCtx.close();

        updateExportProgress(12, 'Processing audio speed...');

        // Use FFmpeg atempo filter to speed up audio while PRESERVING PITCH
        // Also boost volume by 1.5x to match preview loudness
        // atempo can only do 0.5-2.0x, so 1.5x is within range
        const AUDIO_VOLUME_BOOST = 1.5; // Adjust if needed (1.0 = no change, 2.0 = double)
        try {
          await ffmpeg.run(
            '-i', 'audio_original.wav',
            '-filter:a', `atempo=${AUDIO_SPEED},volume=${AUDIO_VOLUME_BOOST}`,
            '-y',
            'audio.wav'
          );
        } catch (atempoErr) {
          console.warn('atempo filter failed, using original audio:', atempoErr);
          // Fallback: just rename
          const origData = ffmpeg.FS('readFile', 'audio_original.wav');
          ffmpeg.FS('writeFile', 'audio.wav', origData);
        }

        // Cleanup original audio
        try { ffmpeg.FS('unlink', 'audio_original.wav'); } catch(e) {}

        updateExportProgress(15, `Rendering ${totalFrames} frames...`);

        // === PRE-EXTRACT VIDEO FRAMES (memory efficient with JPEG data URLs) ===
        let videoFrameBlobs = [];
        if (videoReady && exportVideo.videoWidth > 0) {
          updateExportProgress(16, 'Capturing video frames...');

          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = exportVideo.videoWidth;
          tempCanvas.height = exportVideo.videoHeight;
          const tempCtx = tempCanvas.getContext('2d');

          const frameInterval = 1 / EXPORT_FPS;
          const videoDuration = totalFrames * frameInterval;

          console.log(`Capturing ${totalFrames} frames over ${videoDuration.toFixed(2)}s of video`);

          // Seek to start and wait
          console.log('Seeking to:', bgVideoStartTime, 'video duration:', exportVideo.duration, 'src:', exportVideo.src);
          exportVideo.currentTime = bgVideoStartTime;
          await new Promise(resolve => {
            exportVideo.onseeked = () => resolve();
            setTimeout(resolve, 500);
          });
          console.log('After seek, currentTime:', exportVideo.currentTime, 'readyState:', exportVideo.readyState);

          const useVideoFrameCallback = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;
          console.log('Using requestVideoFrameCallback:', useVideoFrameCallback);

          // Capture frames as data URLs (compressed, much smaller than ImageData)
          if (useVideoFrameCallback) {
            console.log('Using requestVideoFrameCallback for precise frame capture');

            await new Promise(resolve => {
              let framesCaptured = 0;
              const endTime = bgVideoStartTime + videoDuration;

              const captureFrame = (now, metadata) => {
                if (exportVideo.currentTime >= endTime || framesCaptured >= totalFrames) {
                  exportVideo.pause();
                  resolve();
                  return;
                }

                // Capture current frame as JPEG data URL (much smaller than PNG/ImageData)
                tempCtx.drawImage(exportVideo, 0, 0);
                videoFrameBlobs.push(tempCanvas.toDataURL('image/jpeg', 0.92));
                framesCaptured++;

                if (framesCaptured % 30 === 0) {
                  updateExportProgress(16 + (framesCaptured / totalFrames) * 14, `Capturing frame ${framesCaptured}/${totalFrames}`);
                }

                exportVideo.requestVideoFrameCallback(captureFrame);
              };

              exportVideo.requestVideoFrameCallback(captureFrame);
              exportVideo.playbackRate = 1.0;
              exportVideo.play();
            });
          } else {
            console.log('Using timer-based frame capture (requestVideoFrameCallback not available)');

            await new Promise(resolve => {
              let framesCaptured = 0;
              const captureInterval = 1000 / EXPORT_FPS;
              const endTime = bgVideoStartTime + videoDuration;

              const intervalId = setInterval(() => {
                if (exportVideo.currentTime >= endTime || framesCaptured >= totalFrames || exportVideo.paused) {
                  clearInterval(intervalId);
                  exportVideo.pause();
                  resolve();
                  return;
                }

                // Capture current frame as JPEG data URL
                tempCtx.drawImage(exportVideo, 0, 0);
                videoFrameBlobs.push(tempCanvas.toDataURL('image/jpeg', 0.92));
                framesCaptured++;

                if (framesCaptured % 30 === 0) {
                  updateExportProgress(16 + (framesCaptured / totalFrames) * 14, `Capturing frame ${framesCaptured}/${totalFrames}`);
                }
              }, captureInterval);

              exportVideo.playbackRate = 1.0;
              exportVideo.play();
            });
          }

          console.log(`Captured ${videoFrameBlobs.length} frames, expected ${totalFrames}`);

          // Pad with last frame if needed
          while (videoFrameBlobs.length < totalFrames && videoFrameBlobs.length > 0) {
            videoFrameBlobs.push(videoFrameBlobs[videoFrameBlobs.length - 1]);
          }

          console.log(`Captured ${videoFrameBlobs.length} video frames as compressed data URLs`);
        }

        // === FRAME-BY-FRAME RENDERING ===
        const frameDataArray = [];
        const batchSize = 10;

        for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {
          const currentTime = frameIndex / EXPORT_FPS;

          exportCtx.imageSmoothingEnabled = true;
          exportCtx.imageSmoothingQuality = 'high';

          const currentDialogue = timings.find(d => currentTime >= d.start && currentTime < d.end) || timings[0];
          const isStewie = currentDialogue?.speaker === 'stewie';

          exportCtx.clearRect(0, 0, ratio.width, ratio.height);

          // Draw background frame from compressed data URL
          let hasBgFrame = false;
          if (videoFrameBlobs.length > 0 && frameIndex < videoFrameBlobs.length && videoFrameBlobs[frameIndex]) {
            try {
              const bgImg = new Image();
              await new Promise((resolve, reject) => {
                bgImg.onload = resolve;
                bgImg.onerror = reject;
                bgImg.src = videoFrameBlobs[frameIndex];
              });

              const videoAspect = bgImg.width / bgImg.height;
              const canvasAspect = ratio.width / ratio.height;
              let drawW, drawH, drawX, drawY;
              if (videoAspect > canvasAspect) {
                drawH = ratio.height;
                drawW = ratio.height * videoAspect;
                drawX = (ratio.width - drawW) / 2;
                drawY = 0;
              } else {
                drawW = ratio.width;
                drawH = ratio.width / videoAspect;
                drawX = 0;
                drawY = (ratio.height - drawH) / 2;
              }
              exportCtx.drawImage(bgImg, drawX, drawY, drawW, drawH);
              hasBgFrame = true;

              // Clear this frame's data URL to free memory as we go
              videoFrameBlobs[frameIndex] = null;
            } catch (e) {
              console.warn(`Failed to draw bg frame ${frameIndex}:`, e);
            }
          }

          if (!hasBgFrame) {
            const gradient = exportCtx.createLinearGradient(0, 0, 0, ratio.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            exportCtx.fillStyle = gradient;
            exportCtx.fillRect(0, 0, ratio.width, ratio.height);
          }

          const charImg = isStewie ? characterImages.stewie : characterImages.peter;
          if (charImg) {
            const maxCharHeight = ratio.height * 0.5;
            const maxCharWidth = ratio.width * 0.6;
            let scale = Math.min(maxCharHeight / charImg.height, maxCharWidth / charImg.width);
            if (!isStewie) scale *= 1.3;

            const charW = charImg.width * scale;
            const charH = charImg.height * scale;
            const offsetX = ratio.width * 0.1;
            let charX = isStewie ? (ratio.width - charW) / 2 - offsetX : (ratio.width - charW) / 2 + offsetX;
            let charY = ratio.height - charH - (ratio.height * 0.05);
            if (!isStewie) charY += ratio.height * 0.08;

            const isCurrentlySpeaking = currentDialogue && currentTime >= currentDialogue.start && currentTime < currentDialogue.end;
            let shakeX = 0, shakeY = 0;
            if (isCurrentlySpeaking) {
              const shakeTime = frameIndex / EXPORT_FPS;
              shakeX = Math.sin(shakeTime * 5 * 2 * Math.PI) * 4 * 0.2;
              shakeY = Math.cos(shakeTime * 5 * 2 * Math.PI) * 4;
            }

            if (!isStewie) {
              exportCtx.save();
              exportCtx.translate(charX + charW + shakeX, charY + shakeY);
              exportCtx.scale(-1, 1);
              exportCtx.drawImage(charImg, 0, 0, charW, charH);
              exportCtx.restore();
            } else {
              exportCtx.drawImage(charImg, charX + shakeX, charY + shakeY, charW, charH);
            }
          }

          if (currentDialogue?.text) {
            const relTime = currentTime - currentDialogue.start;
            drawKaraokeCaption(exportCtx, currentDialogue, relTime, ratio.width, ratio.height, isStewie);
          }

          const pngBlob = await canvasToPngBlob(exportCanvas);
          const pngArray = new Uint8Array(await pngBlob.arrayBuffer());
          const frameFileName = `frame${String(frameIndex).padStart(6, '0')}.png`;
          ffmpeg.FS('writeFile', frameFileName, pngArray);
          frameDataArray.push(frameFileName);

          if (frameIndex % batchSize === 0 || frameIndex === totalFrames - 1) {
            updateExportProgress(30 + (frameIndex / totalFrames) * 35, `Compositing frame ${frameIndex + 1}/${totalFrames}`);
            await new Promise(r => setTimeout(r, 0));
          }
        }

        // Clear any remaining video frame data
        videoFrameBlobs = null;

        updateExportProgress(68, 'Encoding video with FFmpeg...');

        // === ENCODE WITH FFMPEG ===
        try {
          await ffmpeg.run(
            '-framerate', String(EXPORT_FPS),
            '-i', 'frame%06d.png',
            '-i', 'audio.wav',
            '-c:v', 'libx264',
            '-preset', 'medium',
            '-crf', '18',
            '-pix_fmt', 'yuv420p',
            // Proper color space settings to avoid color shifts
            '-colorspace', 'bt709',
            '-color_primaries', 'bt709',
            '-color_trc', 'bt709',
            '-c:a', 'aac',
            '-b:a', '192k',
            '-shortest',
            '-y',
            'output.mp4'
          );
        } catch (encodeErr) {
          console.error('FFmpeg encoding error:', encodeErr);
          throw new Error('Video encoding failed: ' + encodeErr.message);
        }

        updateExportProgress(92, 'Reading output file...');

        let mp4Data;
        try {
          mp4Data = ffmpeg.FS('readFile', 'output.mp4');
        } catch (readErr) {
          throw new Error('Failed to read encoded video. Encoding may have failed.');
        }

        const finalBlob = new Blob([mp4Data.buffer], { type: 'video/mp4' });

        updateExportProgress(95, 'Cleaning up...');

        // Cleanup FFmpeg filesystem
        try { ffmpeg.FS('unlink', 'audio.wav'); } catch(e) {}
        try { ffmpeg.FS('unlink', 'output.mp4'); } catch(e) {}
        for (const fileName of frameDataArray) {
          try { ffmpeg.FS('unlink', fileName); } catch(e) {}
        }

        updateExportProgress(98, 'Downloading...');

        // Download
        const url = URL.createObjectURL(finalBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `brainrot-${Date.now()}.mp4`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 5000);

        updateExportProgress(100, 'Done!');
        showInfo(`Video exported as high-quality MP4! (${(finalBlob.size / 1024 / 1024).toFixed(1)} MB)`);

      } catch (err) {
        console.error('Export error:', err);
        showError('Export failed: ' + err.message);
      } finally {
        $('#exportBtn').innerHTML = 'Generate Video';
        $('#exportBtn').disabled = false;
        $('#exportProgress').style.display = 'none';
        if (backgroundVideo) {
          backgroundVideo.currentTime = bgVideoStartTime;
        }
        // Re-enable navigation
        $$('.step-btn').forEach(btn => btn.disabled = false);
        $('#backToStep3').disabled = false;
      }
    }

    // Helper: Convert AudioBuffer to WAV format
    function audioBufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;

      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;

      const dataLength = buffer.length * blockAlign;
      const bufferLength = 44 + dataLength;

      const arrayBuffer = new ArrayBuffer(bufferLength);
      const view = new DataView(arrayBuffer);

      // WAV header
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };

      writeString(0, 'RIFF');
      view.setUint32(4, bufferLength - 8, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true); // fmt chunk size
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(36, 'data');
      view.setUint32(40, dataLength, true);

      // Interleave audio data
      const channels = [];
      for (let ch = 0; ch < numChannels; ch++) {
        channels.push(buffer.getChannelData(ch));
      }

      let offset = 44;
      for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          const sample = Math.max(-1, Math.min(1, channels[ch][i]));
          const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(offset, intSample, true);
          offset += 2;
        }
      }

      return arrayBuffer;
    }

    // ========== UI HELPERS ==========
    function showError(msg) {
      $('#errorBanner').textContent = '! ' + msg;
      $('#errorBanner').style.display = 'flex';
      $('#errorBanner').style.background = 'rgba(239, 68, 68, 0.1)';
      $('#errorBanner').style.borderColor = 'rgba(239, 68, 68, 0.3)';
      $('#errorBanner').style.color = '#fca5a5';
    }

    function showInfo(msg) {
      $('#errorBanner').textContent = msg;
      $('#errorBanner').style.display = 'flex';
      $('#errorBanner').style.background = 'rgba(96, 165, 250, 0.1)';
      $('#errorBanner').style.borderColor = 'rgba(96, 165, 250, 0.3)';
      $('#errorBanner').style.color = '#93c5fd';
    }

    function hideError() {
      $('#errorBanner').style.display = 'none';
    }

    function updateProgress(percent, text) {
      $('#progressFill').style.width = `${percent}%`;
      $('#progressText').textContent = text;
    }

    function updateExportProgress(percent, text) {
      $('#exportProgressFill').style.width = `${percent}%`;
      $('#exportProgressText').textContent = text;
    }

    // ========== WINDOW DRAG & RESIZE ==========
    function initWindowControls() {
      const appWindow = $('#appWindow');
      const header = $('#windowHeader');

      // Convert CSS right/bottom positioning to left/top for dragging
      // CSS already positions it at bottom-right, we just convert to left/top
      const rect = appWindow.getBoundingClientRect();
      appWindow.style.right = 'auto';
      appWindow.style.bottom = 'auto';
      appWindow.style.left = rect.left + 'px';
      appWindow.style.top = rect.top + 'px';

      // Dragging state
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      // Resizing state
      let isResizing = false;
      let resizeDir = '';
      let startX, startY, startWidth, startHeight, startLeft, startTop;

      // DRAG functionality (title bar)
      header.addEventListener('mousedown', (e) => {
        if (e.target.closest('.win-btn') || e.target.closest('.logo')) return;
        isDragging = true;
        dragOffsetX = e.clientX - appWindow.offsetLeft;
        dragOffsetY = e.clientY - appWindow.offsetTop;
        appWindow.style.transition = 'none';
      });

      // Bring appWindow to front when clicked anywhere
      appWindow.addEventListener('mousedown', () => {
        bringToFront('appWindow');
      });

      // RESIZE functionality
      document.querySelectorAll('.resize-handle').forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          isResizing = true;
          resizeDir = handle.classList[1]; // top, right, bottom, left, corner, etc.
          startX = e.clientX;
          startY = e.clientY;
          startWidth = appWindow.offsetWidth;
          startHeight = appWindow.offsetHeight;
          startLeft = appWindow.offsetLeft;
          startTop = appWindow.offsetTop;
          appWindow.style.transition = 'none';
          e.preventDefault();
        });
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          let newLeft = e.clientX - dragOffsetX;
          let newTop = e.clientY - dragOffsetY;
          const taskbarHeight = 30;
          // Keep window on screen (accounting for taskbar)
          newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - appWindow.offsetWidth));
          newTop = Math.max(0, Math.min(newTop, window.innerHeight - appWindow.offsetHeight - taskbarHeight));
          appWindow.style.left = newLeft + 'px';
          appWindow.style.top = newTop + 'px';
        }

        if (isResizing) {
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          const minW = 350;
          const minH = 300;
          const taskbarHeight = 30;
          const viewW = window.innerWidth;
          const viewH = window.innerHeight - taskbarHeight;

          // Calculate max dimensions based on current position and viewport
          const currentLeft = appWindow.offsetLeft;
          const currentTop = appWindow.offsetTop;
          const maxWRight = viewW - currentLeft;
          const maxHBottom = viewH - currentTop;

          if (resizeDir === 'right' || resizeDir === 'corner') {
            const newWidth = Math.max(minW, Math.min(maxWRight, startWidth + dx));
            appWindow.style.width = newWidth + 'px';
          }
          if (resizeDir === 'bottom' || resizeDir === 'corner') {
            const newHeight = Math.max(minH, Math.min(maxHBottom, startHeight + dy));
            appWindow.style.height = newHeight + 'px';
          }
          if (resizeDir === 'left' || resizeDir === 'top-left' || resizeDir === 'bottom-left') {
            const maxExpandLeft = startLeft;
            const newWidth = Math.max(minW, Math.min(startWidth + maxExpandLeft, startWidth - dx));
            const newLeft = startLeft + startWidth - newWidth;
            if (newLeft >= 0) {
              appWindow.style.width = newWidth + 'px';
              appWindow.style.left = newLeft + 'px';
            }
          }
          if (resizeDir === 'top' || resizeDir === 'top-left' || resizeDir === 'top-right') {
            const maxExpandTop = startTop;
            const newHeight = Math.max(minH, Math.min(startHeight + maxExpandTop, startHeight - dy));
            const newTop = startTop + startHeight - newHeight;
            if (newTop >= 0) {
              appWindow.style.height = newHeight + 'px';
              appWindow.style.top = newTop + 'px';
            }
          }
          if (resizeDir === 'top-right') {
            const newWidth = Math.max(minW, Math.min(maxWRight, startWidth + dx));
            appWindow.style.width = newWidth + 'px';
          }
          if (resizeDir === 'bottom-left') {
            const newHeight = Math.max(minH, Math.min(maxHBottom, startHeight + dy));
            appWindow.style.height = newHeight + 'px';
          }
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
        isResizing = false;
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        // Keep window in bounds after browser resize
        const maxLeft = window.innerWidth - appWindow.offsetWidth;
        const maxTop = window.innerHeight - appWindow.offsetHeight;
        if (appWindow.offsetLeft > maxLeft) appWindow.style.left = Math.max(0, maxLeft) + 'px';
        if (appWindow.offsetTop > maxTop) appWindow.style.top = Math.max(0, maxTop) + 'px';
      });
    }

    // ========== START MENU ==========
    function toggleStartMenu() {
      const startMenu = document.getElementById('startMenu');
      startMenu.classList.toggle('open');
    }

    // Close start menu when clicking outside
    document.addEventListener('click', (e) => {
      const startMenu = document.getElementById('startMenu');
      const startButton = document.querySelector('.start-button');
      if (startMenu && !startMenu.contains(e.target) && !startButton.contains(e.target)) {
        startMenu.classList.remove('open');
      }
    });

    // ========== FLOATING WINDOWS ==========
    let floatingWindowDrag = { isDragging: false, windowId: null, offsetX: 0, offsetY: 0 };
    let windowZIndex = 100;

    // Window info for taskbar
    const windowInfo = {
      'myDocumentsWindow': { title: 'My Documents', icon: 'folder-icon.png' },
      'recycleBinWindow': { title: 'Recycle Bin', icon: 'recycle-icon.png' },
      'appWindow': { title: 'Brainrot Video Generator', icon: 'computer-icon.png' },
      'mediaPlayerWindow': { title: 'Brainrot Media Player', icon: 'mediaplayer-icon.png' }
    };

    function openWindow(windowId) {
      const win = document.getElementById(windowId);
      if (!win) return;

      // Center media player window every time, default position for others
      if (windowId === 'mediaPlayerWindow') {
        const winWidth = 640;
        const winHeight = 710;
        const taskbarHeight = 30;
        win.style.left = Math.max(0, (window.innerWidth - winWidth) / 2) + 'px';
        win.style.top = Math.max(0, (window.innerHeight - taskbarHeight - winHeight) / 2) + 'px';
      } else if (!win.style.left || win.style.left === '0px') {
        win.style.left = '100px';
        win.style.top = '80px';
      }

      // Use 'block' for shaped windows, 'flex' for regular floating windows
      if (win.classList.contains('shaped-window')) {
        win.style.display = 'block';
      } else {
        win.style.display = 'flex';
      }
      win.classList.remove('minimized');
      bringToFront(windowId);
      addTaskbarButton(windowId);
      updateTaskbarButtons(windowId);

      // Start video when media player is opened
      if (windowId === 'mediaPlayerWindow') {
        const video = document.getElementById('mediaVideo');
        if (video) video.play().catch(() => {});
      }
    }

    function closeWindow(windowId) {
      const win = document.getElementById(windowId);
      if (win) {
        // Pause video when media player is closed
        if (windowId === 'mediaPlayerWindow') {
          const video = document.getElementById('mediaVideo');
          if (video) video.pause();
        }
        win.style.display = 'none';
        win.classList.remove('minimized');
        removeTaskbarButton(windowId);
      }
    }

    function minimizeWindow(windowId) {
      const win = document.getElementById(windowId);
      if (win) {
        win.style.display = 'none';
        win.classList.add('minimized');
        updateTaskbarButtons(null);
      }
    }

    function restoreWindow(windowId) {
      const win = document.getElementById(windowId);
      if (win) {
        // Use 'block' for shaped windows, 'flex' for regular floating windows
        if (win.classList.contains('shaped-window')) {
          win.style.display = 'block';
        } else {
          win.style.display = 'flex';
        }
        win.classList.remove('minimized');
        bringToFront(windowId);
        updateTaskbarButtons(windowId);
      }
    }

    function toggleWindow(windowId) {
      const win = document.getElementById(windowId);
      if (!win) return;

      if (win.classList.contains('minimized')) {
        restoreWindow(windowId);
      } else if (win.classList.contains('active')) {
        minimizeWindow(windowId);
      } else {
        bringToFront(windowId);
        updateTaskbarButtons(windowId);
      }
    }

    function addTaskbarButton(windowId) {
      const taskbarMiddle = document.querySelector('.taskbar-middle');
      if (!taskbarMiddle || document.getElementById('taskbar-btn-' + windowId)) return;

      const info = windowInfo[windowId] || { title: 'Window', icon: 'computer-icon.png' };

      const btn = document.createElement('button');
      btn.className = 'taskbar-window-btn active';
      btn.id = 'taskbar-btn-' + windowId;
      btn.onclick = () => toggleWindow(windowId);
      btn.innerHTML = `<img src="${info.icon}" alt=""><span>${info.title}</span>`;

      taskbarMiddle.appendChild(btn);
    }

    function removeTaskbarButton(windowId) {
      const btn = document.getElementById('taskbar-btn-' + windowId);
      if (btn) btn.remove();
    }

    function updateTaskbarButtons(activeWindowId) {
      document.querySelectorAll('.taskbar-window-btn').forEach(btn => {
        const winId = btn.id.replace('taskbar-btn-', '');
        if (winId === activeWindowId) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }

    // Auto-pause media player video
    function pauseMediaPlayer() {
      const video = document.getElementById('mediaVideo');
      if (video && !video.paused) {
        video.pause();
      }
    }

    // Auto-play media player video
    function playMediaPlayer() {
      const video = document.getElementById('mediaVideo');
      const mediaPlayerWin = document.getElementById('mediaPlayerWindow');
      if (video && video.paused && mediaPlayerWin && mediaPlayerWin.style.display !== 'none') {
        video.play().catch(() => {}); // Catch autoplay restrictions
      }
    }

    // Auto-pause/play when page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        pauseMediaPlayer();
      } else {
        // Auto-play when page becomes visible and media player is active
        const mediaPlayerWin = document.getElementById('mediaPlayerWindow');
        if (mediaPlayerWin && mediaPlayerWin.classList.contains('active')) {
          playMediaPlayer();
        }
      }
    });

    function bringToFront(windowId) {
      // Auto-pause video when any other window is activated
      if (windowId !== 'mediaPlayerWindow') {
        pauseMediaPlayer();
      } else {
        // Auto-play when media player is activated
        playMediaPlayer();
      }

      // Never bring other windows in front of media player
      const mediaPlayerWin = document.getElementById('mediaPlayerWindow');
      if (mediaPlayerWin && mediaPlayerWin.style.display !== 'none' && windowId !== 'mediaPlayerWindow') {
        // Remove active from all windows including media player
        document.querySelectorAll('.floating-window, .shaped-window').forEach(w => {
          w.classList.remove('active');
          w.classList.add('inactive');
        });

        const win = document.getElementById(windowId);
        if (win) {
          windowZIndex++;
          win.style.zIndex = windowZIndex;
          win.classList.remove('inactive');
          win.classList.add('active');
          // Ensure media player stays on top visually (but not active)
          mediaPlayerWin.style.zIndex = windowZIndex + 1;
        }
        return;
      }

      // Remove active class from all windows (both floating and shaped)
      document.querySelectorAll('.floating-window, .shaped-window').forEach(w => {
        w.classList.remove('active');
        w.classList.add('inactive');
      });

      const win = document.getElementById(windowId);
      if (win) {
        windowZIndex++;
        win.style.zIndex = windowZIndex;
        win.classList.remove('inactive');
        win.classList.add('active');
      }
    }

    function startDragWindow(e, windowId) {
      if (e.target.closest('.win-btn')) return;

      bringToFront(windowId);
      const win = document.getElementById(windowId);

      floatingWindowDrag = {
        isDragging: true,
        windowId: windowId,
        offsetX: e.clientX - win.offsetLeft,
        offsetY: e.clientY - win.offsetTop
      };

      e.preventDefault();
    }

    document.addEventListener('mousemove', (e) => {
      if (floatingWindowDrag.isDragging && floatingWindowDrag.windowId) {
        const win = document.getElementById(floatingWindowDrag.windowId);
        if (!win) return;

        const taskbarHeight = 30;
        let newLeft = e.clientX - floatingWindowDrag.offsetX;
        let newTop = e.clientY - floatingWindowDrag.offsetY;

        // Keep window on screen
        newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - win.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, window.innerHeight - win.offsetHeight - taskbarHeight));

        win.style.left = newLeft + 'px';
        win.style.top = newTop + 'px';
      }
    });

    document.addEventListener('mouseup', () => {
      floatingWindowDrag.isDragging = false;
    });

    // ========== MEDIA PLAYER ROTATION ==========
    let mediaPlayerRotation = 0;
    let isRotating = false;
    let rotateStartAngle = 0;

    const rotateHandle = document.getElementById('rotateHandle');
    const mediaPlayerWindow = document.getElementById('mediaPlayerWindow');

    if (rotateHandle && mediaPlayerWindow) {
      // Double-click to reset rotation to 0
      rotateHandle.addEventListener('dblclick', (e) => {
        mediaPlayerRotation = 0;
        mediaPlayerWindow.style.transform = 'rotate(0deg)';
        e.preventDefault();
      });

      rotateHandle.addEventListener('mousedown', (e) => {
        isRotating = true;
        const rect = mediaPlayerWindow.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        rotateStartAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) - (mediaPlayerRotation * Math.PI / 180);
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isRotating) return;
        const rect = mediaPlayerWindow.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
        // Round to 10-degree increments for snappy rotation
        mediaPlayerRotation = Math.round((angle - rotateStartAngle) * 180 / Math.PI / 10) * 10;
        mediaPlayerWindow.style.transform = `rotate(${mediaPlayerRotation}deg)`;
      });

      document.addEventListener('mouseup', () => {
        isRotating = false;
      });
    }

    // ========== TASKBAR CLOCK ==========
    function updateTaskbarClock() {
      const now = new Date();
      let hours = now.getHours();
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12;
      hours = hours ? hours : 12;
      $('#taskbarTime').textContent = `${hours}:${minutes} ${ampm}`;
    }

    // ========== EVENT LISTENERS ==========
    document.addEventListener('DOMContentLoaded', async () => {
      // Initialize window drag/resize
      initWindowControls();

      // Add main app window to taskbar
      addTaskbarButton('appWindow');
      updateTaskbarButtons('appWindow');

      // Initialize taskbar clock
      updateTaskbarClock();
      setInterval(updateTaskbarClock, 1000);

      // Generate debug grid for media player positioning
      function generateDebugGrid() {
        const grid = document.getElementById('debugGrid');
        if (!grid) return;

        const gridSpacing = 25; // pixels between lines
        const imgWidth = 640;
        const imgHeight = 768; // full image height (80% of original)

        // Generate horizontal lines with labels
        for (let y = 0; y <= imgHeight; y += gridSpacing) {
          const line = document.createElement('div');
          line.className = 'grid-line-h';
          line.style.top = y + 'px';
          grid.appendChild(line);

          const label = document.createElement('span');
          label.className = 'grid-label grid-label-h';
          label.style.top = y + 'px';
          label.textContent = y;
          grid.appendChild(label);
        }

        // Generate vertical lines with labels
        for (let x = 0; x <= imgWidth; x += gridSpacing) {
          const line = document.createElement('div');
          line.className = 'grid-line-v';
          line.style.left = x + 'px';
          grid.appendChild(line);

          const label = document.createElement('span');
          label.className = 'grid-label grid-label-v';
          label.style.left = x + 'px';
          label.textContent = x;
          grid.appendChild(label);
        }
      }
      generateDebugGrid();

      // PNG layer manipulation
      window.pngLayers = {
        frame: document.getElementById('layerFrame'),
        righthand: document.getElementById('layerRightHand'),
        main: document.getElementById('layerMain'),
        panel: document.getElementById('layerPanel')
      };

      // Helper function to move a layer
      window.moveLayer = function(layerName, x, y) {
        const layer = window.pngLayers[layerName];
        if (layer) {
          layer.style.transform = `translate(${x}px, ${y}px)`;
        }
      };

      // Helper function to rotate a layer
      window.rotateLayer = function(layerName, angle) {
        const layer = window.pngLayers[layerName];
        if (layer) {
          layer.style.transform = `rotate(${angle}deg)`;
        }
      };

      // Helper function to set multiple transforms
      window.transformLayer = function(layerName, x, y, angle, scale) {
        const layer = window.pngLayers[layerName];
        if (layer) {
          layer.style.transform = `translate(${x || 0}px, ${y || 0}px) rotate(${angle || 0}deg) scale(${scale || 1})`;
        }
      };

      // Helper to set layer z-index
      window.setLayerOrder = function(layerName, zIndex) {
        const layer = window.pngLayers[layerName];
        if (layer) {
          layer.style.zIndex = zIndex;
        }
      };

      console.log('PNG Layers loaded: frame, righthand, main, panel');

      // Slide panel toggle function (moves panel, toggleback, right hand, and buttons together)
      window.toggleSlidePanel = function() {
        const panel = document.getElementById('slidePanel');
        const toggleback = document.getElementById('layerToggleback');
        const rightHand = document.getElementById('layerRightHand');
        const btnSlide = document.getElementById('btnSlide');
        const btnSlide2 = document.getElementById('btnSlide2');
        const btnPlay = document.getElementById('btnPlay');
        const btnPause = document.getElementById('btnPause');
        const btnFastFwd = document.getElementById('btnFastFwd');
        const btnNext = document.querySelector('.btn-next');

        const elements = [panel, toggleback, rightHand, btnSlide, btnSlide2, btnPlay, btnPause, btnFastFwd, btnNext];
        elements.forEach(el => {
          if (el) el.classList.toggle('hidden');
        });
      };

      // Media player controls
      const mediaVideo = document.getElementById('mediaVideo');
      const btnPlay = document.getElementById('btnPlay');
      const btnPause = document.getElementById('btnPause');
      const btnStop = document.getElementById('btnStop');
      const btnRewind = document.getElementById('btnRewind');
      const btnFastFwd = document.getElementById('btnFastFwd');
      const panelFilename = document.getElementById('panelFilename');
      const panelProgress = document.getElementById('panelProgress');
      const panelProgressFill = document.getElementById('panelProgressFill');

      console.log('Media controls init:', { mediaVideo, btnPlay, btnPause, btnStop, btnRewind, btnFastFwd });

      // Update progress bar
      function updateProgress() {
        if (mediaVideo && panelProgressFill && mediaVideo.duration) {
          const percent = (mediaVideo.currentTime / mediaVideo.duration) * 100;
          panelProgressFill.style.width = percent + '%';
        }
      }

      // Seek on progress bar click
      if (panelProgress && mediaVideo) {
        panelProgress.addEventListener('click', (e) => {
          const rect = panelProgress.getBoundingClientRect();
          const percent = (e.clientX - rect.left) / rect.width;
          mediaVideo.currentTime = percent * mediaVideo.duration;
        });
      }

      // Update progress while playing
      if (mediaVideo) {
        mediaVideo.addEventListener('timeupdate', updateProgress);
      }

      // Playlist - loaded from brainrot-videos folder
      const videoFolder = 'brainrot-videos/';
      let playlist = [];
      let currentTrack = 0;
      const panelPlaylist = document.getElementById('panelPlaylist');

      // Load playlist from JSON file (does not auto-play)
      async function loadPlaylist() {
        try {
          const response = await fetch(videoFolder + 'playlist.json?' + Date.now());
          playlist = await response.json();
          currentTrack = Math.floor(Math.random() * playlist.length);
          renderPlaylist();
          // Just load the video source without playing
          if (mediaVideo && playlist.length > 0) {
            mediaVideo.src = videoFolder + playlist[currentTrack];
            updateFilenameDisplay();
          }
        } catch (e) {
          console.error('Failed to load playlist:', e);
          playlist = ['gameplay1.mp4', 'gameplay2.mp4', 'gameplay3.mp4'];
          currentTrack = Math.floor(Math.random() * playlist.length);
          renderPlaylist();
          // Just load the video source without playing
          if (mediaVideo && playlist.length > 0) {
            mediaVideo.src = videoFolder + playlist[currentTrack];
            updateFilenameDisplay();
          }
        }
      }

      // Render playlist UI
      function renderPlaylist() {
        if (!panelPlaylist) return;
        panelPlaylist.innerHTML = '';
        playlist.forEach((file, index) => {
          const item = document.createElement('div');
          item.className = 'panel-playlist-item' + (index === currentTrack ? ' active' : '');
          item.textContent = file;
          item.addEventListener('click', () => playTrack(index));
          panelPlaylist.appendChild(item);
        });
      }

      // Update playlist highlighting
      function updatePlaylistHighlight() {
        if (!panelPlaylist) return;
        const items = panelPlaylist.querySelectorAll('.panel-playlist-item');
        items.forEach((item, index) => {
          item.classList.toggle('active', index === currentTrack);
        });
      }

      // Update filename display
      function updateFilenameDisplay() {
        if (panelFilename && mediaVideo && mediaVideo.src) {
          const filename = decodeURIComponent(mediaVideo.src.split('/').pop().split('?')[0]);
          const text = 'Now Playing: ' + (filename || 'No file');
          panelFilename.textContent = text;

          // Check if text overflows the wrapper and enable scrolling
          panelFilename.classList.remove('scrolling');
          setTimeout(() => {
            const wrapper = panelFilename.parentElement;
            if (panelFilename.scrollWidth > wrapper.clientWidth) {
              panelFilename.textContent = text + '   â€¢   ' + text;
              panelFilename.classList.add('scrolling');
            }
          }, 50);
        }
      }

      // Play a specific track from playlist
      function playTrack(index) {
        if (index >= 0 && index < playlist.length) {
          currentTrack = index;
          mediaVideo.src = videoFolder + playlist[currentTrack];
          mediaVideo.play();
          updateFilenameDisplay();
          updatePlaylistHighlight();
        }
      }

      // Initialize playlist from brainrot-videos folder
      loadPlaylist();

      // Play next track
      function playNext() {
        currentTrack = (currentTrack + 1) % playlist.length;
        playTrack(currentTrack);
      }

      // Play previous track
      function playPrev() {
        currentTrack = (currentTrack - 1 + playlist.length) % playlist.length;
        playTrack(currentTrack);
      }

      // Auto-rotate portrait (9:16) videos to fit landscape screen
      function checkAndRotateVideo() {
        if (!mediaVideo) return;
        const vw = mediaVideo.videoWidth;
        const vh = mediaVideo.videoHeight;
        if (vw && vh && vh > vw) {
          // Portrait video - rotate 90 degrees, swap dimensions, maintain position
          mediaVideo.style.width = '195px';
          mediaVideo.style.height = '295px';
          mediaVideo.style.transform = 'rotate(90deg) translate(-50px, -50px)';
        } else {
          // Landscape video - reset to default
          mediaVideo.style.width = '';
          mediaVideo.style.height = '';
          mediaVideo.style.transform = '';
        }
      }

      // Listen for video source changes and auto-play next
      if (mediaVideo) {
        mediaVideo.addEventListener('loadedmetadata', () => {
          updateFilenameDisplay();
          checkAndRotateVideo();
        });
        mediaVideo.addEventListener('ended', playNext);
        updateFilenameDisplay(); // Initial update
      }

      // Play button (only plays)
      if (btnPlay && mediaVideo) {
        btnPlay.addEventListener('click', () => {
          console.log('Play clicked');
          mediaVideo.play();
        });
      }

      // Pause button (only pauses)
      if (btnPause && mediaVideo) {
        btnPause.addEventListener('click', () => {
          mediaVideo.pause();
        });
      }

      // Stop button
      if (btnStop && mediaVideo) {
        btnStop.addEventListener('click', () => {
          mediaVideo.pause();
          mediaVideo.currentTime = 0;
        });
      }

      // Rewind button
      if (btnRewind && mediaVideo) {
        btnRewind.addEventListener('click', () => {
          mediaVideo.currentTime -= 10; // Rewind 10 seconds
        });
      }

      // Fast forward button
      if (btnFastFwd && mediaVideo) {
        btnFastFwd.addEventListener('click', () => {
          mediaVideo.currentTime += 10; // Skip forward 10 seconds
        });
      }

      // Mute button
      const btnMute = document.getElementById('btnMute');
      if (btnMute && mediaVideo) {
        btnMute.addEventListener('click', () => {
          mediaVideo.muted = !mediaVideo.muted;
          btnMute.textContent = mediaVideo.muted ? 'ðŸ”‡' : 'ðŸ”Š';
          btnMute.dataset.tooltip = mediaVideo.muted ? 'Unmute' : 'Mute';
        });
      }

      // Previous button
      const btnPrev = document.querySelector('.btn-prev');
      if (btnPrev) {
        btnPrev.addEventListener('click', playPrev);
      }

      // Next button
      const btnNextEl = document.querySelector('.btn-next');
      if (btnNextEl) {
        btnNextEl.addEventListener('click', playNext);
      }

      // Load character images
      await loadCharacterImages();

      // Initialize
      renderDialogues();

      // Load saved API key
      const savedKey = localStorage.getItem('elevenlabs_api_key');
      if (savedKey) $('#apiKeyInput').value = savedKey;

      // Step navigation
      $$('.step-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const step = parseInt(btn.dataset.step);
          if (!btn.disabled) goToStep(step);
        });
      });

      // Script editor
      $('#addDialogueBtn').addEventListener('click', addDialogue);
      $('#toStep2Btn').addEventListener('click', () => goToStep(2));

      // Voice generator
      $('#loadVoicesBtn').addEventListener('click', loadVoices);
      $('#generateBtn').addEventListener('click', generateVoices);
      $('#backToStep1').addEventListener('click', () => goToStep(1));
      $('#toStep3Btn').addEventListener('click', () => goToStep(3));

      // Aspect ratio
      $$('.ratio-card').forEach(card => {
        card.addEventListener('click', () => selectRatio(card.dataset.ratio));
      });
      $('#backToStep2').addEventListener('click', () => goToStep(2));
      $('#toStep4Btn').addEventListener('click', () => goToStep(4));

      // Preview - old inline controls removed, now using popup
      // The popup has its own onclick handlers defined inline

      // Navigation and Export
      $('#backToStep3').addEventListener('click', () => goToStep(3));
      $('#exportBtn').addEventListener('click', handleExport);
    });
  </script>
</body>
</html>
